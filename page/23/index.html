<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"l4qiang.me","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="记录点滴，注重积累。">
<meta property="og:type" content="website">
<meta property="og:title" content="CrazyAirhead">
<meta property="og:url" content="http://l4qiang.me/page/23/index.html">
<meta property="og:site_name" content="CrazyAirhead">
<meta property="og:description" content="记录点滴，注重积累。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="L4qiang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://l4qiang.me/page/23/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>CrazyAirhead</title>
  


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2613e7f510eebd12cf4d0d067e4ce195";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">CrazyAirhead</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">疯狂的傻瓜，傻瓜也疯狂——傻方能执著，疯狂才专注!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/crazy-airhead" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/12/05/bigdata/hbase-indexer/getting-start-tutorial/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/bigdata/hbase-indexer/getting-start-tutorial/" class="post-title-link" itemprop="url">Hbase Indexer - 教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-05 12:33:00" itemprop="dateCreated datePublished" datetime="2018-12-05T12:33:00+08:00">2018-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 21:23:05" itemprop="dateModified" datetime="2022-10-30T21:23:05+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>This page explains how to start doing basic indexing in HBase. Before following this tutorial, make sure that the HBase Indexer and other required software is installed and running as explained in the <a target="_blank" rel="noopener" href="https://github.com/NGDATA/hbase-indexer/wiki/Installation">installation instructions</a>.</p>
<p>这篇解释如何在Hbase中开始基础索引。在开始教程之前，请确保Hbase Indexer和其他需要的软件已经<a href="">安装</a>和运行。</p>
<p>At this point, HBase and Solr (in cloud mode) should be running, and the HBase Indexer should be unpacked in a directory (which we’ll call $INDEXER_HOME). For this tutorial, it is assumed that the default example index schema is being used by Solr (as explained on the <a target="_blank" rel="noopener" href="https://github.com/NGDATA/hbase-indexer/wiki/Installation">installation page</a>).</p>
<p>此时，Hbasa和Solr（云模式）已经行行，并且Hbase Indexer已经解压到一个目录中（这是我们称为<code>$INDEXER_HOME</code>）。在这个教程中，我们假设用的是Solr的默认example索引（就像<a target="_blank" rel="noopener" href="https://github.com/NGDATA/hbase-indexer/wiki/Installation">安装</a>中说的那样）。</p>
<h2 id="启动Hbase-Indexer（Start-the-HBase-Indexer-daemon）"><a href="#启动Hbase-Indexer（Start-the-HBase-Indexer-daemon）" class="headerlink" title="启动Hbase Indexer（Start the HBase Indexer daemon）"></a>启动Hbase Indexer（Start the HBase Indexer daemon）</h2><p>In a terminal, execute the following (assuming $INDEXER_HOME points to the directory where the hbase-indexer tar.gz distribution was unpacked).</p>
<p>在终端中，运行如下命令（假定<code>$INDEXER_HOME</code>指向hbase-indexer tar.gz解压的目录）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $INDEXER_HOME</span><br><span class="line">./bin/hbase-indexer server</span><br></pre></td></tr></table></figure>

<h2 id="创建需要索引的表（Create-a-table-to-be-indexed-in-HBase）"><a href="#创建需要索引的表（Create-a-table-to-be-indexed-in-HBase）" class="headerlink" title="创建需要索引的表（Create a table to be indexed in HBase）"></a>创建需要索引的表（Create a table to be indexed in HBase）</h2><p>In the HBase shell, create a table. For this tutorial, we’ll create a table named “indexdemo-user”, with a single column family named “info”. Note that the <code>REPLICATION_SCOPE</code> of the column family of the table must be set to 1.</p>
<p>在Hbase shell，创建一个表。在这里，我们创建一个“indexdemo-user”的表，有一个“info”的列簇。注意列簇的<code>REPLICATION_SCOPE</code>必须设置成1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hbase shell</span><br><span class="line">hbase&gt; create &#x27;indexdemo-user&#x27;, &#123; NAME =&gt; &#x27;info&#x27;, REPLICATION_SCOPE =&gt; &#x27;1&#x27; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加索引器（Add-an-indexer）"><a href="#添加索引器（Add-an-indexer）" class="headerlink" title="添加索引器（Add an indexer）"></a>添加索引器（Add an indexer）</h2><p>Now we’ll create an indexer that will index the the indexdemo-user table as its contents are updated.</p>
<p>现在我们创建一个索引器，在indexdemo-user表的内容被更新是他会进行索引。</p>
<p>In your favourite text editor, create a new xml file called indexdemo-indexer.xml, with the following content:</p>
<p>用你喜欢的编辑器，创建一个新的xml文件，命名为<code>indexdemo-indexer.xml</code>，添加如下内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">indexer</span> <span class="attr">table</span>=<span class="string">&quot;indexdemo-user&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;firstname_s&quot;</span> <span class="attr">value</span>=<span class="string">&quot;info:firstname&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;lastname_s&quot;</span> <span class="attr">value</span>=<span class="string">&quot;info:lastname&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;age_i&quot;</span> <span class="attr">value</span>=<span class="string">&quot;info:age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">indexer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>The above file defines three pieces of information that will be used for indexing, how to interpret them, and how they will be stored in Solr.</p>
<p>上面的文件定义了三个索引字段的信息，如何解析，如何在Solr中存储。</p>
<p>Next, create an indexer based on the created indexer xml file.</p>
<p>接下来，基于xml文件创建一个索引器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./bin/hbase-indexer add-indexer -n myindexer -c indexdemo-indexer.xml \</span><br><span class="line">        -cp solr.zk=localhost:2181/solr -cp solr.collection=collection1</span><br></pre></td></tr></table></figure>

<p>Note that the above command assumes that ZooKeeper is running on localhost on port 2181, and that there is a Solr Core called “collection1” configured. If you are doing this tutorial on an existing HBase/Solr environment, you may need to use different settings.</p>
<p>注意上面的命令假设，ZooKeeper运行要本机的2181端口上，并且Solr Core已经创建了一个名为“collection1”的索引。如果你在一个现有的Hbase/Solr环境运行本教程，你需要修改配置。</p>
<h2 id="更新表内容（Update-the-table-content）"><a href="#更新表内容（Update-the-table-content）" class="headerlink" title="更新表内容（Update the table content）"></a>更新表内容（Update the table content）</h2><p>In the HBase shell, try adding some data to the indexdemo-user table<br>在Hbase shell中，尝试给<code>indexdemo-user</code>添加一些数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; put &#x27;indexdemo-user&#x27;, &#x27;row1&#x27;, &#x27;info:firstname&#x27;, &#x27;John&#x27;</span><br><span class="line">hbase&gt; put &#x27;indexdemo-user&#x27;, &#x27;row1&#x27;, &#x27;info:lastname&#x27;, &#x27;Smith&#x27;</span><br></pre></td></tr></table></figure>
<p>After adding this data, take a look in Solr (i.e. <a target="_blank" rel="noopener" href="http://localhost:8983/solr/#/collection1/query">http://localhost:8983/solr/#/collection1/query</a>). You should see a single document in Solr that has the firstname_s field set to “John”, and the lastname_s field set to “Smith”.</p>
<p>添加数据之后，来看一下Solr（i.e. <a target="_blank" rel="noopener" href="http://localhost:8983/solr/#/collection1/quer%EF%BC%89%EF%BC%8C%E4%BD%A0%E5%BA%94%E8%AF%A5%E8%83%BD%E7%9C%8B%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%96%87%E6%A1%A3%E7%9A%84firstname_s%E5%AD%97%E6%AE%B5%E5%80%BC%E4%B8%BA%E2%80%9CJohn%E2%80%9D%EF%BC%8C%E5%90%8C%E6%97%B6lastname_s%E5%AD%97%E6%AE%B5%E5%80%BC%E4%B8%BA%E2%80%9CSmith%E2%80%9D%E3%80%82">http://localhost:8983/solr/#/collection1/quer），你应该能看到一个文档，这个文档的firstname_s字段值为“John”，同时lastname_s字段值为“Smith”。</a></p>
<p>Note If you don’t have autoCommit enabled in Solr, you won’t be able to see the updated contents immediately in Solr. The demo environment has autoCommit enabled for a commit every second.</p>
<p><strong>注意</strong>如果没有开启<code>autoCommit</code>，你不会马上在Solr看到更新的内容。这例子的环境<code>autoCommit</code>已经开启并设置为每秒自动提交1次。</p>
<p>Now try updating the data you’ve just added</p>
<p>现在尝试更新你刚才添加的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; put &#x27;indexdemo-user&#x27;, &#x27;row1&#x27;, &#x27;info:firstname&#x27;, &#x27;Jim&#x27;</span><br></pre></td></tr></table></figure>
<p>And now check the content in Solr. The document’s firstname_s field now contains the string “Jim”.</p>
<p>然后在Solr有检查内容。看下文档的firstname_s是不是变成了“Jim”</p>
<p>Finally, delete the row from HBase.</p>
<p>最后，删除Hbase的这条记录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; deleteall &#x27;indexdemo-user&#x27;, &#x27;row1&#x27;</span><br></pre></td></tr></table></figure>

<p>You can now verify that the data has been deleted from Solr.</p>
<p>你可以验证下Solr中的数据是不是已经删除了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/12/05/bigdata/hbase-indexer/getting-start-install/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/bigdata/hbase-indexer/getting-start-install/" class="post-title-link" itemprop="url">Hbase Indexer - 安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-05 12:32:00" itemprop="dateCreated datePublished" datetime="2018-12-05T12:32:00+08:00">2018-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 21:23:05" itemprop="dateModified" datetime="2022-10-30T21:23:05+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>This page explains how to do a basic installation of the HBase Indexer on a single machine.</p>
<p>这篇会讲解如何在单机中进行Hbase Indexer的基础安装。</p>
<p>Before you start, make sure that you have the <a target="_blank" rel="noopener" href="https://github.com/NGDATA/hbase-indexer/wiki/Requirements">required software</a> installed (they can all be running on single machine).</p>
<p>在开始之前，请确认你已经安装了所有需要的软件（他们可以都可以在单机运行）。</p>
<h2 id="获取Hbase-Indexer（Get-the-HBase-Indexer）"><a href="#获取Hbase-Indexer（Get-the-HBase-Indexer）" class="headerlink" title="获取Hbase Indexer（Get the HBase Indexer）"></a>获取Hbase Indexer（Get the HBase Indexer）</h2><p>Check out the code and build the tar.gz distribution.</p>
<p>签出代码并生成tar.gz的发布包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/NGDATA/hbase-indexer.git</span><br><span class="line">mvn clean package -Pdist -DskipTests</span><br></pre></td></tr></table></figure>

<p>Next, unpackage the tar.gz distribution (in the example below it is unpacked under your $HOME directory).</p>
<p>接下来，解压tar.gz发布包（这个例子中，他被解压到<code>$HOME</code>目录）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf hbase-indexer-dist/target/hbase-indexer-1.0-SNAPSHOT.tar.gz -C ~</span><br><span class="line">cd ~/hbase-indexer-1.0-SNAPSHOT</span><br></pre></td></tr></table></figure>

<h2 id="配置Hbase-Indexer（Configure-HBase-Indexer）"><a href="#配置Hbase-Indexer（Configure-HBase-Indexer）" class="headerlink" title="配置Hbase Indexer（Configure HBase Indexer）"></a>配置Hbase Indexer（Configure HBase Indexer）</h2><p>In the hbase-indexer directory, edit the file <code>conf/hbase-indexer-site.xml</code> and configure the ZooKeeper connection string (twice, once for hbase-indexer, and once for hbase, alternatively you can copy your <code>hbase-site.xml</code>to the conf directory).</p>
<p>在<code>hbase-indexer</code>目录，编辑<code>conf/hbase-indexer-site.xml</code> 文件并配置ZooKeeper的连接串（两次，一次用于hbase-indexer,一次用于Hbase，或者你可以拷贝你的<code>hbase-site.xml</code>到你的<code>conf</code>目录）。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbaseindexer.zookeeper.connectstring<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>zookeeperhost<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>zookeeperhost<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>If you have not defined <code>JAVA_HOME</code> globally, and the <code>bin/hbase-indexer</code> script would complain it doesn’t find you Java, you can set the JAVA_HOME in the script <code>conf/hbase-indexer-env.sh</code>.</p>
<p>如果你没有定义全局的<code>JAVA_HOME</code>，<code>bin/hbase-indexer</code>脚本会报没有找到Java，你可以通过运行<code>conf/hbase-indexer-env.sh</code>来设置<code>JAVA_HOME</code>。</p>
<h2 id="配置Hbase（Configure-HBase）"><a href="#配置Hbase（Configure-HBase）" class="headerlink" title="配置Hbase（Configure HBase）"></a>配置Hbase（Configure HBase）</h2><p>In order to use the HBase Indexer, <a target="_blank" rel="noopener" href="http://hbase.apache.org/replication.html">replication</a> must be enabled in HBase. There are also a number of other HBase settings that can be set to optimize the working of the HBase indexer.</p>
<p>为了运行Hbase Indexer，<a target="_blank" rel="noopener" href="http://hbase.apache.org/replication.html">复制集</a>必须开启。同时还有一些HBase的设置需要配置以便优代Hbase Indexer的运行。</p>
<p>Add the settings below to your hbase-site.xml configuration on all HBase region servers, and restart HBase.<br>所有的分区服务上的<code>hbase-site.xml</code>添加如下配置，然后重启Hbase。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- SEP is basically replication, so enable it --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Source ratio of 100% makes sure that each SEP consumer is actually</span></span><br><span class="line"><span class="comment">       used (otherwise, some can sit idle, especially with small clusters) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>replication.source.ratio<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Maximum number of hlog entries to replicate in one go. If this is</span></span><br><span class="line"><span class="comment">       large, and a consumer takes a while to process the events, the</span></span><br><span class="line"><span class="comment">       HBase rpc call will time out. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>replication.source.nb.capacity<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- A custom replication source that fixes a few things and adds</span></span><br><span class="line"><span class="comment">       some functionality (doesn&#x27;t interfere with normal replication</span></span><br><span class="line"><span class="comment">       usage). --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>replication.replicationsource.implementation<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.ngdata.sep.impl.SepReplicationSource<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="添加Indexer-jar到HBase（Add-indexer-jars-to-HBase）"><a href="#添加Indexer-jar到HBase（Add-indexer-jars-to-HBase）" class="headerlink" title="添加Indexer jar到HBase（Add indexer jars to HBase）"></a>添加Indexer jar到HBase（Add indexer jars to HBase）</h2><p>The HBase Indexer includes two jar files that need to be in the classpath of HBase. Copy these from the lib directory of the unpacked hbase-indexer installation into the lib directory of HBase for each region server.</p>
<p>Hbase Indexer包含两个jar文件需要在Hbase的类目录下。将解压目录hbase-indexer下的lib中的这些文件拷贝到所有Hbase分区服务器的lib目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp lib/hbase-sep-* $HBASE_HOME/lib</span><br></pre></td></tr></table></figure>
<h2 id="启动Solr（Start-Solr）"><a href="#启动Solr（Start-Solr）" class="headerlink" title="启动Solr（Start Solr）"></a>启动Solr（Start Solr）</h2><p>Ensure that Solr is running. In general, it’s easiest to have Solr use the same ZooKeeper instance as HBase.</p>
<p>确保Solr已经运行。通常，很容易让Hbase和Solr共用相同的ZooKeeper。</p>
<p>Assuming that you’ve downloaded Solr 4.2.0 and you’re running ZooKeeper on the current machine, you can start up the base Solr in cloud mode using the example schema as follows:</p>
<p>假设你已经下载了Solr 4.2.0并且ZooKeeper运行在当前机器，你可能通过下列脚本在云模式运行Solr。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $SOLR_HOME/example</span><br><span class="line">java -Dbootstrap_confdir=./solr/collection1/conf -Dcollection.configName=myconf -DzkHost=localhost:2181/solr  -jar start.jar</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/12/05/bigdata/hbase-indexer/getting-start/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/bigdata/hbase-indexer/getting-start/" class="post-title-link" itemprop="url">Hbase Indexer - 入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-05 12:31:00" itemprop="dateCreated datePublished" datetime="2018-12-05T12:31:00+08:00">2018-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 21:23:05" itemprop="dateModified" datetime="2022-10-30T21:23:05+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="构建（Building-the-binary-distribution）"><a href="#构建（Building-the-binary-distribution）" class="headerlink" title="构建（Building the binary distribution）"></a>构建（Building the binary distribution）</h2><p>Use the following command to build the binary distribution (.tar.gz &amp; rpm):</p>
<p>使用如下命令构建生成二进制发布包（.tar.gz &amp; rpm）:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -DskipTests -Pdist install</span><br></pre></td></tr></table></figure>

<h2 id="测试（Testing）"><a href="#测试（Testing）" class="headerlink" title="测试（Testing）"></a>测试（Testing）</h2><p>These steps assume a running HBase 0.94.x installation (preferably CDH 4.2), as well as a running Solr installation. For this example, the configured Solr schema will need to have a multi-valued field called “data”, as well as a unique key field called “id”.</p>
<p>以下这此步骤假定已经安装了Hbase 0.94.x(最好是CDH 4.2)和Solr。在这个例子中，Solr的映射，需要配置多值字段“data”和唯一键字段“id”。</p>
<ol>
<li><p>Enable replication and other settings that are outlined in the <a target="_blank" rel="noopener" href="https://github.com/NGDATA/hbase-indexer/blob/master/hbase-sep/hbase-sep-demo/README.md">hbase-sep demo instructions</a></p>
</li>
<li><p>按<a target="_blank" rel="noopener" href="https://github.com/NGDATA/hbase-indexer/blob/master/hbase-sep/hbase-sep-demo/README.md">hbase-sep demo instructions</a>的配置复制集和其他设置。</p>
</li>
<li><p>Unzip the binary distribution (instructions for creating the binary distribution are listed above).</p>
</li>
<li><p>解压发布包（生成发布包的方式已经在上文列出）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tar zxvf hbase_indexer.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>Copy the hbase-sep jar files from the lib directory of the binary distribution into the lib directory of HBase.</p>
</li>
<li><p>将发布包下的lib目录的hbase-sep jar文件拷贝到Hbase的lib目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd hbase_indexer</span><br><span class="line">$ sudo cp lib/hbase-sep-* /usr/lib/hbase/lib</span><br></pre></td></tr></table></figure></li>
<li><p>Create a table in HBase that has replication enabled. For this example, we’ll create a table called “record” with a single column family called ‘data’.</p>
</li>
<li><p>创建一个开启复制集功能的表。这个例子中，我们会创建“record”表，有一个列簇“data”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; create &#x27;record&#x27;, &#123;NAME =&gt; &#x27;data&#x27;, REPLICATION_SCOPE =&gt; 1&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Start the hbase-indexer server</p>
</li>
<li><p>启动hbase-indexer服务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/hbase-indexer server</span><br></pre></td></tr></table></figure></li>
<li><p>Create an indexer definition. For this example, we’ll just index anything in the data column family into the “data” field in Solr. Save the below contents in a file called ‘sample.xml’.</p>
</li>
<li><p>创建索引器定义。在这个例子中，我们只是把data列簇中所有内容都放到Solr的“data”字段中进行索引。将以下内容保存为”sample.xml”。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">indexer</span> <span class="attr">table</span>=<span class="string">&quot;record&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;data&quot;</span> <span class="attr">value</span>=<span class="string">&quot;data:*&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">indexer</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>Add the indexer definition to the indexer server. The following command assumes that the Solr ZooKeeper is running on the current host, and the name of the collection to be used for indexing is “core0”.</p>
</li>
<li><p>把索引定义添加到inderxer服务中。下面的命令假设Solr ZooKeeper运行在当前的主机中，并且用于索引的集合名为“core0”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/hbase-indexer add-indexer  -n sampleindex -c sample.xml --cp solr.collection=core0 </span><br></pre></td></tr></table></figure></li>
<li><p>Add some data to the record table in HBase. The data added to the data column family in the record table should show up in the Solr index.</p>
</li>
<li><p>向Hbase的recode表添加一些数据。添加到record表中的数据应该会出现在Solr的索引中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase&gt; put &#x27;record&#x27;, &#x27;row1&#x27;, &#x27;data:value&#x27;, &#x27;Test of HBase Indexer&#x27;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/12/05/bigdata/hbase-indexer/requirements/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/bigdata/hbase-indexer/requirements/" class="post-title-link" itemprop="url">Hbase Indexer - 要求</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-05 12:30:00" itemprop="dateCreated datePublished" datetime="2018-12-05T12:30:00+08:00">2018-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 21:23:05" itemprop="dateModified" datetime="2022-10-30T21:23:05+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>The following software is required for running the HBase Indexer:</p>
<p>运行Hbase Indexer需要下面的这些软件:</p>
<ul>
<li>HBase 0.94.x</li>
<li>Solr 4.x in cloud mode</li>
<li>ZooKeeper 3.x (required by the two above packages)</li>
</ul>
<p>All components can be run on a single machine, or they can be run on multiple machines on a cluster.</p>
<p>所有的组件可以运行在单机，也可运行在多台机器的集群上。</p>
<h2 id="详情（Details）"><a href="#详情（Details）" class="headerlink" title="详情（Details）"></a>详情（Details）</h2><h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>HBase 0.94.x is the supported version of HBase for the HBase Indexer. It is recommended to use the version of HBase 0.94.2 that is bundled with Cloudera CDH 4.2. However, other versions of HBase 0.94.x may also work. CDH 4.2 is currently used for testing.</p>
<p>Hbase 0.94.x是Hbase Indexer支持的版本。推荐使用Cloudera CDH 4.2附带的HBase 0.94.2版本。尽管，其他的0.94.x版本也能正常工作，但CDH 4.2被用于当前的测试。</p>
<p>HBase should be configured to use HDFS as its filesystem – HBase Indexer is not fully functional if the local filesystem implementation is used instead of HDFS.</p>
<p>Hbase要配置HDFS做为它的文件系统，如果使用本地文件系统而不是HDFS，HBase Indexer就不行完全运行了。</p>
<h2 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h2><p>Solr 4.x is required for the HBase Indexer, and it must be configured to run in cloud mode. Solr 4.2.0 is currently used for development testing.</p>
<p>Hbase Indexer 需要Solr 4.x版本，并且要求配置在云模式下运行。Solr 4.2.0是当并开发测试的版本。</p>
<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>It is recommended that the version of ZooKeeper that is bundled in CDH 4.2 is used.</p>
<p>推荐使用和CDH4.2附带的ZooKeeper版本。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/12/05/bigdata/hbase-indexer/home/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/12/05/bigdata/hbase-indexer/home/" class="post-title-link" itemprop="url">Hbase Index - 首页</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-12-05 12:20:00" itemprop="dateCreated datePublished" datetime="2018-12-05T12:20:00+08:00">2018-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 21:23:05" itemprop="dateModified" datetime="2022-10-30T21:23:05+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介（Introduction）"><a href="#简介（Introduction）" class="headerlink" title="简介（Introduction）"></a>简介（Introduction）</h2><p>The HBase Indexer project provides indexing (via <a target="_blank" rel="noopener" href="http://lucene.apache.org/solr/">Solr</a>) for content stored in <a target="_blank" rel="noopener" href="http://hbase.apache.org/">HBase</a>. It provides a flexible and extensible way of defining indexing rules, and is designed to scale.</p>
<p>Hbase Indexer项目可以为存储在HBase中的内容提供<a target="_blank" rel="noopener" href="http://lucene.apache.org/solr/">Solr</a>索引。它提供灵活的可扩展的方式来定义索引规则，且为大规模而生。</p>
<p>Indexing is performed asynchronously, so it does not impact write throughput on HBase. SolrCloud is used for storing the actual index in order to ensure scalability of the indexing.</p>
<p>索引是异步的，所以不会影响Hbase的写入吞吐量。SolrCloud用于存储实际的索引，以确保索引的可伸缩性。</p>
<h2 id="开始使用Hbase-Indexer（Getting-started-with-the-HBase-Indexer）"><a href="#开始使用Hbase-Indexer（Getting-started-with-the-HBase-Indexer）" class="headerlink" title="开始使用Hbase Indexer（Getting started with the HBase Indexer）"></a>开始使用Hbase Indexer（Getting started with the HBase Indexer）</h2><ol>
<li><p>Make sure you’ve got the required software installed, as detailed on the <a target="_blank" rel="noopener" href="https://github.com/NGDATA/hbase-indexer/wiki/Requirements">Requirements</a> page.</p>
</li>
<li><p>Follow the Tutorial to get a feel for how to use the HBase Indexer.</p>
</li>
<li><p>Customize your indexing setup as needed using the other reference documentation provided here.</p>
</li>
<li><p>确认所有要求的软件已经安装，具体内容在[要求]页。</p>
</li>
<li><p>按照教程来体验下如何使用Hbase Indexer。</p>
</li>
<li><p>通过提供的文档来调整索引的配置。</p>
</li>
</ol>
<h2 id="工作原理（How-it-works）"><a href="#工作原理（How-it-works）" class="headerlink" title="工作原理（How it works）"></a>工作原理（How it works）</h2><p>The HBase Indexer works by acting as an HBase replication sink. As updates are written to HBase region servers, they are “replicated” asynchronously to the HBase Indexer processes.</p>
<p>Hbase Indxer扮演了Hbase复制集的角色。当数据写入Hbase的分区时，数据被异步的“复制”给Hbase Indexer处理器。</p>
<p>The indexer analyzes incoming HBase mutation events, and where applicable it creates Solr documents and pushes them to SolrCloud servers.</p>
<p>Hbase Indexer分析从Hbase发送过来的变化事件，当合适的时候创建Solr文档并发送给SolrCloud服务器。</p>
<p>The indexed documents in Solr contain enough information to uniquely identify the HBase row that they are based on, allowing you to use Solr to search for content that is stored in HBase.</p>
<p>Solr文档维护了足够多的信息用于唯一标识一条Hbase记录，这样允许你可能通过Solr来检索Hbase内容。</p>
<p>HBase replication is based on reading the HBase log files, which are the precise source of truth of the what is stored in HBase: there are no missing or no extra events. In various cases, the log also contains all the information needed to index, so that no expensive random-read on HBase is necessary (see the <code>read-row</code>attribute in the <a target="_blank" rel="noopener" href="https://github.com/NGDATA/hbase-indexer/wiki/Indexer-configuration">Indexer Configuration</a>).</p>
<p>HBase复制集是通过读取Hbase的日志文件，这些日志文件是HBASE中存储内容的精确来源：没有遗漏也没有额外的事件。在大多数情况下，日志含了索引需要的全部信息，因此不需要对Hbase进行昂贵的随机读取。（在[Indexer配置]中可查看<code>read-row</code>属性）。</p>
<p>HBase replication delivers (small) batches of events. HBase-indexer exploits this by avoiding double-indexing of the same row if it would have been updated twice in a short time frame, and as well will batch/buffer the updates towards Solr, which gives important performance gains. The updates are applied to Solr before confirming the processing of the events to HBase, so that no event loss is possible.</p>
<p>Hbase复制集（小规模）批量分发事件。Hbase indexer利用这一特性用于避免在一个很小的时间窗口期一条记录被更新两次而引起重复索引，也通过批量/缓存的方式来更新Solr，这样可以获得更好的性能。所有的更新会在Hbase处理确认之前更新到Solr中，因此不会出现丢失数据的情况。</p>
<h2 id="横向扩展（Horizontal-scalability）"><a href="#横向扩展（Horizontal-scalability）" class="headerlink" title="横向扩展（Horizontal scalability）"></a>横向扩展（Horizontal scalability）</h2><p>All information about indexers is stored in ZooKeeper. New indexer hosts can always be added to a cluster, in the same way that HBase regionservers can be added to to an HBase cluster.</p>
<p>所有的索引信息都是保存在ZooKeeper中的。新的Indexer主机可以被添加为一个集群中，就像Hbase的分区服务器被添加到Hbase集群一样。</p>
<p>All indexing work for a single configured indexer is shared over all machines in the cluster. In this way, adding additional indexer nodes allows horizontal scaling.</p>
<p>同一索引配置的所有索引工作被分配给集群中的所有机器。这样说来，添加额外的索引节点就可以横向扩展。</p>
<h2 id="自动的错误处理（Automatic-failure-handling）"><a href="#自动的错误处理（Automatic-failure-handling）" class="headerlink" title="自动的错误处理（Automatic failure handling）"></a>自动的错误处理（Automatic failure handling）</h2><p>The HBase replication system upon which the HBase Indexer is based is designed to handle hardware failures. Because the HBase Indexer is based on this system, it also benefits from the same ability to handle failures.</p>
<p>Hbase复制集系统为硬件错误处理做了设计。Hbase Indexer其于此系统，因此也从中获得了错误处理的能力。</p>
<p>In general, indexing nodes going down or Solr nodes going down will not result in any lost data in the HBase Indexer.</p>
<p>通常情况，索引节点或者Solr宕机不会导致Hbase Indexer中的数据丢失。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/29/bigdata/hbase-indexer/loss-data/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/29/bigdata/hbase-indexer/loss-data/" class="post-title-link" itemprop="url">Hbase同步Solr数据缺失问题验证</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-29 13:30:00" itemprop="dateCreated datePublished" datetime="2018-11-29T13:30:00+08:00">2018-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 21:23:05" itemprop="dateModified" datetime="2022-10-30T21:23:05+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/" itemprop="url" rel="index"><span itemprop="name">hbase</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hbase/hbase-indexer/" itemprop="url" rel="index"><span itemprop="name">hbase indexer</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>公司使用Hbase indexer做二级索引，最近在做数据统计时发现，数据存在有缺失的情况。在网上查找时发现可能是Hbase Indexer的一个BUG，详情看<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kekukekro/p/6340922.htm">这里</a>。大意是说修改read-row=”never”或者修改源码。我们使用的组件不是完全开源的Hbase Indexer，有被提供商做了部分调整，为了保险起见，自己还是做了一次测试。同时也是进一步了解Hbase和Habse Indexer的机会。</p>
<h1 id="验证方案"><a href="#验证方案" class="headerlink" title="验证方案"></a>验证方案</h1><ol>
<li>把ES的qc索引做为数据来源，数据量比较大</li>
<li>写测试程序从ES拉数据，100万条。</li>
<li>调整不同的read-row方式</li>
<li>修改程序验证部分更新。<h1 id="验证准备"><a href="#验证准备" class="headerlink" title="验证准备"></a>验证准备</h1><h2 id="创建Hbase表"><a href="#创建Hbase表" class="headerlink" title="创建Hbase表"></a>创建Hbase表</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create <span class="string">&#x27;qc&#x27;</span>,&#123;NAME =&gt;<span class="string">&#x27;d&#x27;</span>, REPLICATION_SCOPE =&gt;1&#125;</span><br></pre></td></tr></table></figure>
此处需要，注意设置REPLICATION_SCOPE为1，第一次验证时未开启。如果未开启的情况，可以进行如下操作：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">disable</span> <span class="string">&#x27;qc&#x27;</span></span><br><span class="line">alter <span class="string">&#x27;qc&#x27;</span>,&#123;NAME =&gt;<span class="string">&#x27;d&#x27;</span>, REPLICATION_SCOPE =&gt;1&#125;</span><br><span class="line"><span class="built_in">enable</span> <span class="string">&#x27;qc&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置Hbase-Indexer"><a href="#配置Hbase-Indexer" class="headerlink" title="配置Hbase Indexer"></a>配置Hbase Indexer</h2>之前已经有配置，拷贝一份及可<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>  /opt/morphline_config</span><br><span class="line">cp -a xyz.xml qc.xml</span><br><span class="line">cp -a xyz.conf qc.conf</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="修改qc-xml"><a href="#修改qc-xml" class="headerlink" title="修改qc.xml"></a>修改qc.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">indexer</span> <span class="attr">table</span>=<span class="string">&quot;qc&quot;</span> <span class="attr">unique-key-field</span>=<span class="string">&quot;rowkey&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">unique-key-formatter</span>=<span class="string">&quot;com.ngdata.hbaseindexer.uniquekey.StringUniqueKeyFormatter&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">mapper</span>=<span class="string">&quot;com.ngdata.hbaseindexer.morphline.MorphlineResultToSolrMapper&quot;</span> <span class="attr">read-row</span>=<span class="string">&quot;never&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;morphlineFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/opt/morphline_config/qc.conf&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">indexer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="修改qc-conf"><a href="#修改qc-conf" class="headerlink" title="修改qc.conf"></a>修改qc.conf</h3><p>可以把文件下载回来修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sz qc.conf</span><br></pre></td></tr></table></figure>
<p>通过’rz’可以上传修改后的配置文件。</p>
<h4 id="调整后的qc-conf"><a href="#调整后的qc-conf" class="headerlink" title="调整后的qc.conf"></a>调整后的qc.conf</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">morphlines : [</span><br><span class="line">  &#123;</span><br><span class="line">    id : morphline1</span><br><span class="line">    importCommands : [<span class="string">&quot;org.kitesdk.morphline.**&quot;</span>, <span class="string">&quot;com.ngdata.**&quot;</span>]</span><br><span class="line"></span><br><span class="line">    commands : [</span><br><span class="line">        &#123;</span><br><span class="line">                extractHBaseCells &#123;</span><br><span class="line">                  mappings : [</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:_id&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;_id&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:code&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;code&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:errorCode&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;errorCode&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:errorMsg&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;errorMsg&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:eventNo&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;eventNo&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:eventTime&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;eventTime&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:orgCode&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;orgCode&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:patientId&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;patientId&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:receiveTime&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;receiveTime&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:rowKey&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;rowKey&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:table&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;table&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:value&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;value&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                                inputColumn : <span class="string">&quot;d:version&quot;</span></span><br><span class="line">                                outputField : <span class="string">&quot;version&quot;</span></span><br><span class="line">                                type : string</span><br><span class="line">                                isAllowEmpty : <span class="literal">true</span></span><br><span class="line">                                source : value</span><br><span class="line">                        &#125;                                          </span><br><span class="line">                        ]		</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#123; logTrace &#123; format : <span class="string">&quot;output record: &#123;&#125;&quot;</span>, args : [<span class="string">&quot;@&#123;&#125;&quot;</span>] &#125; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="添加映射"><a href="#添加映射" class="headerlink" title="添加映射"></a>添加映射</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase-indexer add-indexer -c qc.xml -n qc -z node1,node3,node2  -cp solr.zk=node1:2181,node3:2181,node2:2181/solr -cp solr.collection=qc</span><br></pre></td></tr></table></figure>
<h3 id="检查配置是否生效"><a href="#检查配置是否生效" class="headerlink" title="检查配置是否生效"></a>检查配置是否生效</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase-indexer list-indexers -dump</span><br></pre></td></tr></table></figure>
<h3 id="删除映射"><a href="#删除映射" class="headerlink" title="删除映射"></a>删除映射</h3><p>如果配置没有生效的情况，最好先删掉映射后重新添加。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hbase-indexer delete-indexer --name &#x27;qc&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="重新拉取Hbase数据"><a href="#重新拉取Hbase数据" class="headerlink" title="重新拉取Hbase数据"></a>重新拉取Hbase数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup hadoop jar /opt/hbase-indexer/latest/tools/hbase-indexer-mr-1.6-ngdata-job.jar  --conf /etc/hbase/conf/hbase-site.xml -D &#x27;mapred.child.java.opts=-Xmx500m&#x27; --hbase-indexer-file /opt/morphline_config/qc.xml --zk-host node1/solr --collection qc  --reduce 0 &amp;</span><br></pre></td></tr></table></figure>
<h2 id="配置Solr"><a href="#配置Solr" class="headerlink" title="配置Solr"></a>配置Solr</h2><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>之前有配置的，可直接拷贝一份开始配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /root</span><br><span class="line">cp -a xyz qc</span><br></pre></td></tr></table></figure>
<h4 id="修改后的scheme-xml"><a href="#修改后的scheme-xml" class="headerlink" title="修改后的scheme.xml"></a>修改后的scheme.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xmlversion=&quot;1.0&quot;encoding=&quot;UTF-8&quot;standalone=&quot;no&quot;?&gt;</span></span><br><span class="line">&lt;schemaname=&quot;qc&quot;version=&quot;1.5&quot;&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;_version_&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;long&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span><span class="attr">name</span>=<span class="string">&quot;_root_&quot;</span><span class="attr">stored</span>=<span class="string">&quot;false&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span><span class="attr">multiValued</span>=<span class="string">&quot;false&quot;</span><span class="attr">name</span>=<span class="string">&quot;_id&quot;</span><span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">multiValued</span>=<span class="string">&quot;false&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rowkey&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;code&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;false&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;errorCode&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;errorMsg&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;eventNo&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;eventTime&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;orgCode&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;patientId&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;receiveTime&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;false&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rowKey&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;table&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;value&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">name</span>=<span class="string">&quot;version&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">uniqueKey</span>&gt;</span>rowkey<span class="tag">&lt;/<span class="name">uniqueKey</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此处注意配置rowkey字段，之前一就因为rowkey没有导致创建索引失败</p>
<h2 id="上传配置"><a href="#上传配置" class="headerlink" title="上传配置"></a>上传配置</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/solr/latest/server/scripts/cloud-scripts/zkcli.sh -zkhost node1:2181/solr -cmd upconfig --confdir /root/qc/conf/ --confname qc</span><br></pre></td></tr></table></figure>
<h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/solr/latest/bin/solr create_collection -c qc -d /root/qc/conf/ -n qc</span><br></pre></td></tr></table></figure>
<h2 id="修改ES配置"><a href="#修改ES配置" class="headerlink" title="修改ES配置"></a>修改ES配置</h2><p>拉取测试数据时，提示只有10000的窗口数据，需要设计max_result_window，修改方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST &#x27;http://xx:9200/qc/_close&#x27;</span><br><span class="line">curl -XPUT &#x27;http://xx:9200/qc/_settings?preserve_existing=true&#x27; -d &#x27;&#123;&quot;max_result_window&quot; : &quot;1000000&quot;&#125;&#x27;</span><br><span class="line">curl -XGET &#x27;http://xx:9200/qc/_settings?preserve_existing=true&#x27;</span><br><span class="line">curl -XPOST &#x27;http://xx:9200/qc/_open&#x27; </span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="read-row为never"><a href="#read-row为never" class="headerlink" title="read-row为never"></a>read-row为never</h2><ol>
<li>测试数据为100万条，全量数据更新。<br>数据测试，导入数据时出现服务连接问题，中间出现Hbase Indexer异常停止，重启后，数据能对上。</li>
<li>测试数据为100万条，部分数据更新。<br>数据字段出现丢失情况，</li>
<li>验证配置字段顺序问题。<h2 id="清理Hbase数据"><a href="#清理Hbase数据" class="headerlink" title="清理Hbase数据"></a>清理Hbase数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate &#x27;qc&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="清理Solr数据"><a href="#清理Solr数据" class="headerlink" title="清理Solr数据"></a>清理Solr数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -rm -r /solr/qc</span><br><span class="line">hdfs dfs -ls /solr</span><br></pre></td></tr></table></figure>
验证的情况，与配置文件的顺序无关</li>
</ol>
<h2 id="验证重跑MapRedurce"><a href="#验证重跑MapRedurce" class="headerlink" title="验证重跑MapRedurce"></a>验证重跑MapRedurce</h2><h3 id="删除solr中qc的记录"><a href="#删除solr中qc的记录" class="headerlink" title="删除solr中qc的记录"></a>删除solr中qc的记录</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span>&gt;</span><span class="tag">&lt;<span class="name">query</span>&gt;</span>*:*<span class="tag">&lt;/<span class="name">query</span>&gt;</span><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">commit</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="重跑"><a href="#重跑" class="headerlink" title="重跑"></a>重跑</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup hadoop jar /opt/hbase-indexer/latest/tools/hbase-indexer-mr-1.6-ngdata-job.jar  --conf /etc/hbase/conf/hbase-site.xml -D <span class="string">&#x27;mapred.child.java.opts=-Xmx500m&#x27;</span> --hbase-indexer-file /opt/morphline_config/qc.xml --zk-host node1/solr --collection qc  --reduce 0 &amp;</span><br></pre></td></tr></table></figure>
<p>测试时发现可以正常拉取数据，正式线发现不能拉取到之前遗漏的数据。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol>
<li>修改read-row为never</li>
<li>重新检查写入Hbase相关代码，确保数据是整条记录更新（即需要合并旧数据的方式进行更新）</li>
</ol>
<p><strong>注意事项</strong>，采用read-row为never时，只会从WAL中获取数据去更新Solr，也就是说如果，数据只更新部分，Solr也只会有最后更新的那部分数据。<br>3. 通过写程序将缺失数据提取出来重新更新Hbase，该工作已让郑维协助处理，保持跟进。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kekukekro/p/6340922.html">Lily HBase Indexer同步HBase二级索引到Solr丢失数据的问题分析</a> </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/27/misc/notepad-plus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/27/misc/notepad-plus/" class="post-title-link" itemprop="url">notepad++添加插件管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-27 15:07:40" itemprop="dateCreated datePublished" datetime="2018-11-27T15:07:40+08:00">2018-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 21:23:05" itemprop="dateModified" datetime="2022-10-30T21:23:05+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/misc/" itemprop="url" rel="index"><span itemprop="name">misc</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>424</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>使用Notepad++有挺长一段时间了。因为打开速度快，经常会用它来编绎有一些小文本，或者文件的格式化。在一次升级后发现Json Viwer插件不见了。<br>当时也没太在意，换了一台电脑用了。最近因为查问题需要格式化的JSON也多了起来，就想查查到底是怎么回事，顺便记录下处理方式。</p>
<p>网上一搜还有不少碰到这个问题的人<a target="_blank" rel="noopener" href="https://www.cnblogs.com/holab/p/8593359.html">notepad++64位添加Plugin Manager</a>。大意是64位已经不提供plugin manager了。可以通过<a target="_blank" rel="noopener" href="https://github.com/bruderstein/nppPluginManager/releases">https://github.com/bruderstein/nppPluginManager/releases</a>下载Plugin Manager。下载之后，用覆盖的方式粘贴plugins和updater文件夹，重新启动就可以。</p>
<p>启动之后提示，32位Notepad++不能运行64位插件。索性重新下载了个新版本的Notepad++64位，plugin manager已经改名为Plugin Admin了。下载我自己需要的插件，一切正常。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/chapter-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/chapter-6/" class="post-title-link" itemprop="url">Go Little Book - 第六章 - 并发</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:45:44" itemprop="dateCreated datePublished" datetime="2018-11-22T10:45:44+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 21:23:05" itemprop="dateModified" datetime="2022-10-30T21:23:05+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>21k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>19 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第六章-并发-Chapter-6-Concurrency"><a href="#第六章-并发-Chapter-6-Concurrency" class="headerlink" title="第六章 - 并发(Chapter 6 - Concurrency)"></a>第六章 - 并发(Chapter 6 - Concurrency)</h1><p>Go is often described as a concurrent-friendly language. The reason for this is that it provides a simple syntax over two powerful mechanisms: goroutines and channels.</p>
<p>Go常被描述为是一种适用于并发的语言。是因为它在两个强大的机制提供了简法的语法支持：<code>go协程</code>和<code>通道</code>。</p>
<h2 id="Go协程-Goroutines"><a href="#Go协程-Goroutines" class="headerlink" title="Go协程(Goroutines)"></a>Go协程(Goroutines)</h2><p>A goroutine is similar to a thread, but it is scheduled by Go, not the OS. Code that runs in a goroutine can run concurrently with other code. Let’s look at an example:</p>
<p>一个Go协程和一个线程类似，只不这它是由Go,而不是系统来调度的。在协程中的代码可以和其他代码并发执行。让我们看一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;start&quot;</span>)</span><br><span class="line">  <span class="keyword">go</span> process()</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">10</span>) <span class="comment">// this is bad, don&#x27;t do this! 这样不好，不能这么做！</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;processing&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There are a few interesting things going on here, but the most important is how we start a goroutine. We simply use the <code>go</code> keyword followed by the function we want to execute. If we just want to run a bit of code, such as the above, we can use an anonymous function. Do note that anonymous functions aren’t only used with goroutines, however.</p>
<p>这里有几个有趣的地方，但最重要的是我们如何开启一个Go协程。我们只是简单的使用了<code>go</code>关键字后紧跟我们需的执行的函数。如果我们只是要运行一小段代码，比如上面的例子，我们可以使用匿名函数。但是记住，匿名函数不只适用于Go协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">&quot;processing&quot;</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>Goroutines are easy to create and have little overhead. Multiple goroutines will end up running on the same underlying OS thread. This is often called an M:N threading model because we have M application threads (goroutines) running on N OS threads. The result is that a goroutine has a fraction of overhead (a few KB) than OS threads. On modern hardware, it’s possible to have millions of goroutines.</p>
<p>Go协程创建简单和开销小。多个Go协程最终会运行在一个系统线程中。这通常称为<code>M:N</code>线程模型，因为我们有<code>M</code>个应用线程（Go协程）运行在<code>N</code>个系统线程上。结果就是，一个Go协程的开销比系统线程小（一般都是几KB）。在现代的硬件上，有可能创建成千上万个Go协程。</p>
<p>Furthermore, the complexity of mapping and scheduling is hidden. We just say <em>this code should run concurrently</em> and let Go worry about making it happen.</p>
<p>此外，因为隐藏了映射和调度的复杂性。我们只需要说<em>这段代码需要并发执行</em>，然后让Go自己来运行它。</p>
<p>If we go back to our example, you’ll notice that we had to <code>Sleep</code> for a few milliseconds. That’s because the main process exits before the goroutine gets a chance to execute (the process doesn’t wait until all goroutines are finished before exiting). To solve this, we need to coordinate our code.</p>
<p>回到我们的例子中，你将会注意到我们使用了<code>Sleep</code>让程序等待了几毫秒。这是让主进程在退出前有机会去执行协程（主进程退出时不会等待所有协程都执行结束）。为了解决这个问题，我们必须让代码协同。</p>
<h2 id="同步-Synchronization"><a href="#同步-Synchronization" class="headerlink" title="同步(Synchronization)"></a>同步(Synchronization)</h2><p>Creating goroutines is trivial, and they are so cheap that we can start many; however, concurrent code needs to be coordinated. To help with this problem, Go provides <code>channels</code>. Before we look at <code>channels</code>, I think it’s important to understand a little bit about the basics of concurrent programming.</p>
<p>创建Go协程是容易的，而且他们的开销很小，所以我们可以开启很多Go协程；但是并发代码需要协同。为了帮助我们解决这个问题，Go提供了<code>通道</code>。在我们继续<code>通道</code>之前，我觉得有必要先了解一些并发编程的基础知识。</p>
<p>Writing concurrent code requires that you pay specific attention to where and how you read and write values. In some ways, it’s like programming without a garbage collector – it requires that you think about your data from a new angle, always watchful for possible danger. Consider:</p>
<p>在编写并发执行的代码时，你需要特别的注意在哪里和如何读写一个值。出于某些原因，例如没有垃圾回收的语言，需要你从一个新的角度去考虑你的数据，总是警惕着可能存在的危险。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> incr()</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">  counter++</span><br><span class="line">  fmt.Println(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What do you think the output will be?</p>
<p>你觉得输出的会是什么呢？</p>
<p>If you think the output is <code>1, 2</code> you’re both right and wrong. It’s true that if you run the above code, you’ll very likely get that output. However, the reality is that the behavior is undefined. Why? Because we potentially have multiple (two in this case) goroutines writing to the same variable, <code>counter</code>, at the same time. Or, just as bad, one goroutine would be reading <code>counter</code> while another writes to it.</p>
<p>如果你觉得输出是<code>1</code>和<code>2</code>，不能说你对或者错。如果你运行上面的代码，你很有可能得到那样的输出。但是，实际上这个输出是不确定的。为什么？因为我们可能有多个（这里是2个）Go协程同时写同一个变量<code>counter</code>。或者更糟的情况是一个协程正在读<code>counter</code>，而另一个协程正在写<code>counter</code>。</p>
<p>Is that really a danger? Yes, absolutely. <code>counter++</code> might seem like a simple line of code, but it actually gets broken down into multiple assembly statements – the exact nature is dependent on the platform that you’re running. It’s true that, in this example, the most likely case is things will run just fine. However, another possible outcome would be that they both see <code>counter</code> when its equal to <code>0</code> and you get an output of <code>1, 1</code>. There are worse possibilities, such as system crashes or accessing an arbitrary piece of data and incrementing it!</p>
<p>这很危险吗？是的，绝对的。<code>counter++</code>似乎看起来只是一行简单的代码，但是实际上它被拆分为很多汇编指令————具体依赖于你运行的软件和硬件平台。是的，在上面的例子中，确实在大多数情况下运行良好。但是，其他一些平台可能的输出结果是<code>1, 1</code>，因为两个协程看到的<code>counter</code>都是<code>0</code>。还有更糟的情况是，比如系统崩溃或者访问到一个随机值并递增它。</p>
<p>The only concurrent thing you can safely do to a variable is to read from it. You can have as many readers as you want, but writes need to be synchronized. There are various ways to do this, including using some truly atomic operations that rely on special CPU instructions. However, the most common approach is to use a mutex:</p>
<p>在并发编程中维一安全的事情就是读一个变量。无论你想读多少次都可以，但是写变量时必须是同步的。有几种方式来实现，包括一些在特定CPU架构上真正的原子操作。但是，最常见的方式就是用互斥锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  counter = <span class="number">0</span></span><br><span class="line">  lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> incr()</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">()</span></span> &#123;</span><br><span class="line">  lock.Lock()</span><br><span class="line">  <span class="keyword">defer</span> lock.Unlock()</span><br><span class="line">  counter++</span><br><span class="line">  fmt.Println(counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A mutex serializes access to the code under lock. The reason we simply define our lock as <code>lock sync.Mutex</code> is because the default value of a <code>sync.Mutex</code> is unlocked.</p>
<p>互斥锁会顺序化有锁的代码的访问。因为<code>sync.Mutex</code>默认值是未锁状态，所以我们简单的定义了一个锁<code>lock sync.Mutex</code>。</p>
<p>Seems simple enough? The example above is deceptive. There’s a whole class of serious bugs that can arise when doing concurrent programming. First of all, it isn’t always so obvious what code needs to be protected. While it might be tempting to use coarse locks (locks that cover a large amount of code), that undermines the very reason we’re doing concurrent programming in the first place. We generally want fine locks; else, we end up with a ten-lane highway that suddenly turns into a one-lane road.</p>
<p>看起来足够简单？上面的例子有欺骗性。在并发编程时，会碰到一系列很严重的bug。首先，那些需要被保护代码通常都不是这么明显。虽然它可能是想使用一个粗锁（涵盖了大量代码的锁），但这破坏了并发编程首要原则。我们需要适度的锁，或者说，我们最终由一个10快车道的突然转变成一个单车道。</p>
<p>The other problem has to do with deadlocks. With a single lock, this isn’t a problem, but if you’re using two or more locks around the same code, it’s dangerously easy to have situations where goroutineA holds lockA but needs access to lockB, while goroutineB holds lockB but needs access to lockA.</p>
<p>另一个问题是如何处理死锁。只有一个锁的时候，这不是问题，但是如果你在相同的代码中使用2个或者更多的锁，就很容易出现一种危险的情况，即协程A拥有锁<code>lockA</code>，想去访问锁<code>lockB</code>，同时协程B拥有<code>lockB</code>并需要访问锁<code>lockA</code>。</p>
<p>It actually <em>is</em> possible to deadlock with a single lock, if we forget to release it. This isn’t as dangerous as a multi-lock deadlock (because those are <em>really</em> tough to spot), but just so you can see what happens, try running:</p>
<p>实际上使用一个锁<em>也有</em>可能发生死锁，如果我们忘记释放它时。但是这和多个锁引起的死锁为比起来，危害性不大（因为这<em>真的</em>很少出现），但只是想让你看会发生什么，试试下面的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  lock sync.Mutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; lock.Lock() &#125;()</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line">  lock.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s more to concurrent programming than what we’ve seen so far. For one thing, there’s another common mutex called a read-write mutex. This exposes two locking functions: one to lock for reading and one to lock for writing. This distinction allows multiple simultaneous readers while ensuring that writing is exclusive. In Go, <code>sync.RWMutex</code> is such a lock. In addition to the <code>Lock</code> and <code>Unlock</code> methods of a <code>sync.Mutex</code>, it also exposes <code>RLock</code> and <code>RUnlock</code> methods; where <code>R</code> stands for <em>Read</em>. While read-write mutexes are commonly used, they place an additional burden on developers: we must now pay attention to not only when we’re accessing data, but also how.</p>
<p>接下来我们会介绍更多的并发编程。一方面，另一个常见的互斥锁叫读写互斥锁。它主要提供2中锁功能：一个读锁定和一个写锁定。在Go中，<code>sync.RWMutex</code>就是这种锁。另外<code>sync.Mutex</code>结构不但提供了<code>Lock</code>和<code>Unlock</code>方法，也提供了<code>RLock</code>和<code>RLock</code>方法，这里的<code>R</code>代表<em>读</em>。虽然读写锁很常用，但是他们也给开发者带来一些额外的负担：我们不但要关注我们何时访问数据，而且也要关注如何访问。</p>
<p>Furthermore, part of concurrent programming isn’t so much about serializing access across the narrowest possible piece of code; it’s also about coordinating multiple goroutines. For example, sleeping for 10 milliseconds isn’t a particularly elegant solution. What if a goroutine takes more than 10 milliseconds? What if it takes less and we’re just wasting cycles? Also, what if instead of just waiting for goroutines to finish, we want to tell one <em>hey, I have new data for you to process!</em>?</p>
<p>此外，部分并发编程不只是通过为数不多代码按顺序的访问变量，也需要协调多个go协程。例如，休眠10毫秒不是一种优雅的方法。如果一个Go协程运行的时间超过10毫秒呢？如果Go协程运行时间少于10毫秒，我们只是浪费了cpu？又或者可以等待Go协程运行完毕，我们告诉另外一个Go协程<em>嗨，我有一些新数据给你处理？</em></p>
<p>These are all things that are doable without <code>channels</code>. Certainly for simpler cases, I believe you <strong>should</strong> use primitives such as <code>sync.Mutex</code> and <code>sync.RWMutex</code>, but as we’ll see in the next section, <code>channels</code> aim at making concurrent programming cleaner and less error-prone.</p>
<p>所有的这些事在不使用通道的情况下也都是可以实现的。当然，对于更简单的例子，我认为你应该使用基本的功能例如<code>sync.Mutex</code>和<code>sync.RWMutex</code>，但是在下一节我们将看到，通道的目的是为了使并发编程更清晰和不易出错。</p>
<h2 id="通道-Channels"><a href="#通道-Channels" class="headerlink" title="通道(Channels)"></a>通道(Channels)</h2><p>The challenge with concurrent programming stems from sharing data. If your goroutines share no data, you needn’t worry about synchronizing them. That isn’t an option for all systems, however. In fact, many systems are built with the exact opposite goal in mind: to share data across multiple requests. An in-memory cache or a database, are good examples of this. This is becoming an increasingly common reality.</p>
<p>并发编程的最在挑战来自共享数据。如果你的Go协程没有共享数据，你不需要担心他们之间的同步。但是这不是所有系统的选择。事实上，许多系统的构建就是为了：在多个请求中共享数据。内存缓存或者数据库，都是很好的例子。这也成为越来越普遍的事实。</p>
<p>Channels help make concurrent programming saner by taking shared data out of the picture. A channel is a communication pipe between goroutines which is used to pass data. In other words, a goroutine that has data can pass it to another goroutine via a channel. The result is that, at any point in time, only one goroutine has access to the data.</p>
<p>通过共享数据规划，通道使并发编程更清晰。一个通道是一个通信管道用于Go协程之间的数据传递。换一句话来说。一个Go协程可以通过通道来把数据传递给另一个Go协程。这样做的结果就是，无论什么时间节点，都只有一个Go协程可以访问共享数据。</p>
<p>A channel, like everything else, has a type. This is the type of data that we’ll be passing through our channel. For example, to create a channel which can be used to pass an integer around, we’d do:</p>
<p>通道和其他类型一样有类型。这个类型就是我们将在通道中传递的数据类型。例如，创建一个用来传递整数的通道，我们这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>The type of this channel is <code>chan int</code>. Therefore, to pass this channel to a function, our signature looks like:</p>
<p>这个通道的类型是<code>chan int</code>。因此，将这个通道传递给一个函数是，可以这样声明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Channels support two operations: receiving and sending. We send to a channel by doing:</p>
<p>通道支持2种操作：接收和发送。我们可以使用下面方式往通道发送数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANNEL &lt;- DATA</span><br></pre></td></tr></table></figure>

<p>and receive from one by doing</p>
<p>然后可以使用下面方式从通道接收数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VAR := &lt;-CHANNEL</span><br></pre></td></tr></table></figure>

<p>The arrow points in the direction that data flows. When sending, the data flows into the channel. When receiving, the data flows out of the channel.</p>
<p>箭头的方向就是数据的流动方向。当发送数据时，数据流入通道。当发送数据时，数据是流出通道。</p>
<p>The final thing to know before we look at our first example is that receiving and sending to and from a channel is blocking. That is, when we receive from a channel, execution of the goroutine won’t continue until data is available. Similarly, when we send to a channel, execution won’t continue until the data is received.</p>
<p>最后，在看我们的第一个例子之前，从一个通道接收或者发送数据时会阻塞。也就是说，当我们从一个通道接收数据时，直到数据可用Go协程才会继续执行。类似的，往一个通道发送数据时，在数据被接收之前Go协程也不会继续执行。</p>
<p>Consider a system with incoming data that we want to handle in separate goroutines. This is a common requirement. If we did our data-intensive processing on the goroutine which accepts the incoming data, we’d risk timing out clients. First, we’ll write our worker. This could be a simple function, but I’ll make it part of a structure since we haven’t seen goroutines used like this before:</p>
<p>假设这样的一个系统，我们想通过不同的协程来处理输入数据。这是一个常见的需求。如果通过Go协程接收输入的数据并进行数据密集型处理，那么在客户端会有超时风险。首先，我们将写出我们的处理器。这是一个简单的函数，但是我会让它变成一个结构体的部分，因为我们之前从来没有这样使用过Go协程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">  id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">process</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    data := &lt;-c</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d got %d\n&quot;</span>, w.id, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Our worker is simple. It waits until data is available then “processes” it. Dutifully, it does this in a loop, forever waiting for more data to process.</p>
<p>我们的处理器很简单。它会一直等待直到数据可用并“处理”它。它通过一个循环来实现，永久等待更多的数据来处理。</p>
<p>To use this, the first thing we’d do is start some workers:</p>
<p>为了使用上面的代码，我们首先要做的是启动一些处理器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">  worker := Worker&#123;id: i&#125;</span><br><span class="line">  <span class="keyword">go</span> worker.process(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And then we can give them some work:</p>
<p>然后我们可以给他们一些工作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  c &lt;- rand.Int()</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here’s the complete code to make it run:</p>
<p>下面是完整的可执行代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">  <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    worker := &amp;Worker&#123;id: i&#125;</span><br><span class="line">    <span class="keyword">go</span> worker.process(c)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    c &lt;- rand.Int()</span><br><span class="line">    time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">  id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *Worker)</span> <span class="title">process</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    data := &lt;-c</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d got %d\n&quot;</span>, w.id, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We don’t know which worker is going to get what data. What we do know, what Go guarantees, is that the data we send to a channel will only be received by a single receiver.</p>
<p>我们不知道哪个处理器将获得数据。我们所知道的是，Go确保了往一个通道发送数据时，仅有一个单独的接收器可以接受。</p>
<p>Notice that the only shared state is the channel, which we can safely receive from and send to concurrently. Channels provide all of the synchronization code we need and also ensure that, at any given time, only one goroutine has access to a specific piece of data.</p>
<p>需要指出的是通道是唯一的共享方式，通过通道我们可以并发安全的发送和接收数据。通道提供了我们需要的所有同步代码，并且也确保在任意的特定时刻只有一个Go协程可以访问一个特定的数据。</p>
<h3 id="带缓存的通道-Buffered-Channels"><a href="#带缓存的通道-Buffered-Channels" class="headerlink" title="带缓存的通道(Buffered Channels)"></a>带缓存的通道(Buffered Channels)</h3><p>Given the above code, what happens if we have more data coming in than we can handle? You can simulate this by changing the worker to sleep after it has received data:</p>
<p>在上面的代码中，如果输入的数据超过我们可以处理的数据会发生什么？你可以模拟这种场景，在处理器收到数据后执行<code>time.Sleep</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  data := &lt;-c</span><br><span class="line">  fmt.Printf(<span class="string">&quot;worker %d got %d\n&quot;</span>, w.id, data)</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">500</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>What’s happening is that our main code, the one that accepts the user’s incoming data (which we just simulated with a random number generator) is blocking as it sends to the channel because no receiver is available.</p>
<p>在<code>main</code>函数中会发什么呢？接收用户的输入数据（这里通过一个随机的数字生成器模拟）会被阻塞，因为往通道发送数据时没有可用的接收者。</p>
<p>In cases where you need high guarantees that the data is being processed, you probably will want to start blocking the client. In other cases, you might be willing to loosen those guarantees. There are a few popular strategies to do this. The first is to buffer the data. If no worker is available, we want to temporarily store the data in some sort of queue. Channels have this buffering capability built-in. When we created our channel with <code>make</code>, we can give our channel a length:</p>
<p>在这种情况下，你需要确保数据被处理，你可能想要让客户端阻塞。在其他情况下，你可能愿意不确保数据被处理。这里有一些流行的策略能完成此事。首先是将数据缓存起来。如果没有处理器可用，我们想将数据暂时存放在一个有序的队列中。通道内置缓存能力。当我们使用<code>make</code>创建一个通道时，我们可以指定通道的长度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>You can make this change, but you’ll notice that the processing is still choppy. Buffered channels don’t add more capacity; they merely provide a queue for pending work and a good way to deal with a sudden spike. In our example, we’re continuously pushing more data than our workers can handle.</p>
<p>你可以做这样的修改，但是你将注意到处理过程仍然震荡。缓冲通道没有增加处理能力，他们只是为挂起的工作提供了一个队列和应对突发尖峰的好方法。在我们示例中，我们持续不断的发送超出我们处理器可以处理的数据。</p>
<p>Nevertheless, we can get a sense that the buffered channel is, in fact, buffering by looking at the channel’s <code>len</code>:</p>
<p>尽管如此，事实上，我们可以查看通道的<code>len</code>,来了解到带缓存的通道的缓冲情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  c &lt;- rand.Int()</span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(c))</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can see that it grows and grows until it fills up, at which point sending to our channel start to block again.</p>
<p>你可以看到它的长度在不断增大，直到装满为止，此时，往通道发送的数据又开始被阻塞。</p>
<h3 id="选择-Select"><a href="#选择-Select" class="headerlink" title="选择(Select)"></a>选择(Select)</h3><p>Even with buffering, there comes a point where we need to start dropping messages. We can’t use up an infinite amount of memory hoping a worker frees up. For this, we use Go’s <code>select</code>.</p>
<p>即使借助缓存，有一点需要指出的是，我们需要开始丢弃一些消息，我们不能使用一个无限大的内存，并指望人工的释放它。所以我们使用Go的<code>select</code>。</p>
<p>Syntactically, <code>select</code> looks a bit like a switch. With it, we can provide code for when the channel isn’t available to send to. First, let’s remove our channel’s buffering so that we can clearly see how <code>select</code> works:</p>
<p>在语法结构上，<code>select</code>看起来有点类似<code>switch</code>。通过<code>select</code>，我们能写出一些针对通道不可写情况下的代码。首先，让我们去掉我们通道的缓存，这样可以更清晰的看到<code>select</code>是如何工作的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>Next, we change our <code>for</code> loop:</p>
<p>接下来，我们修改<code>for</code>循环：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> c &lt;- rand.Int():</span><br><span class="line">    <span class="comment">//optional code here</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">//this can be left empty to silently drop the data</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;dropped&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>We’re pushing out 20 messages per second, but our workers can only handle 10 per second; thus, half the messages get dropped.</p>
<p>我们每秒往通道中发送20个信息，但是我们的处理器每秒只能处理10个信息；因此，有一半的信息被丢弃。</p>
<p>This is only the start of what we can accomplish with <code>select</code>. A main purpose of select is to manage multiple channels. Given multiple channels, <code>select</code> will block until the first one becomes available. If no channel is available, <code>default</code> is executed if one is provided. A channel is randomly picked when multiple are available.</p>
<p>这仅仅只是我们使用<code>select</code>完成一些事的开始。使用<code>select</code>的最主要目的是通过它管理多个通道。给定多个通道，<code>select</code>将阻塞直到有一个通道可用。如果没有可用的通道，当提供了<code>default</code>语句时，执行该分支。当多个通道都可用时，选择其中的一个通道是随机的。</p>
<p>It’s hard to come up with a simple example that demonstrates this behavior as it’s a fairly advanced feature. The next section might help illustrate this though.</p>
<p>很难想出一个简单的例子来证明这种行为，因为这是一种高级特性。在下一小节可能有助于说明这个问题。</p>
<h3 id="超时-Timeout"><a href="#超时-Timeout" class="headerlink" title="超时(Timeout)"></a>超时(Timeout)</h3><p>We’ve looked at buffering messages as well as simply dropping them. Another popular option is to timeout. We’re willing to block for some time, but not forever. This is also something easy to achieve in Go. Admittedly, the syntax might be hard to follow but it’s such a neat and useful feature that I couldn’t leave it out.</p>
<p>我们已经学习了缓存消息和简单丢弃消息。另外一种比较流行的做法是使用超时。我们将阻塞一段时间，但不是一直阻塞。在Go中这很容易实现。老实说，这个语法有点难于接受，但是它是比较灵活和有用的特性，我基本不能没有它。</p>
<p>To block for a maximum amount of time, we can use the <code>time.After</code> function. Let’s look at it then try to peek beyond the magic. To use this, our sender becomes:</p>
<p>为了达到阻塞的最大时限，我们可以使用<code>time.After</code>函数。让我们看看它，并试着看出其中的魔法。为了使用这种方式，我们的发送器需要修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> c &lt;- rand.Int():</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">100</span>):</span><br><span class="line">    fmt.Println(<span class="string">&quot;timed out&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>time.After</code> returns a channel, so we can <code>select</code> from it. The channel is written to after the specified time expires. That’s it. There’s nothing more magical than that. If you’re curious, here’s what an implementation of <code>after</code> could look like:</p>
<p><code>time.After</code>返回一个通道，所以我们可以对它使用<code>select</code>语法。当指定的时间到期时这个通道被写入。就是如此。没有其他更多的魔法了。如果你还是好奇，这里有一个<code>after</code>的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">after</span><span class="params">(d time.Duration)</span> <span class="title">chan</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(d)</span><br><span class="line">    c &lt;- <span class="literal">true</span></span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Back to our <code>select</code>, there are a couple of things to play with. First, what happens if you add the <code>default</code> case back? Can you guess? Try it. If you aren’t sure what’s going on, remember that <code>default</code> fires immediately if no channel is available.</p>
<p>回到我们的<code>select</code>中来，还一些内容可以研究。首先，如果添加了<code>default</code>条件会发生会什么呢？你可以猜猜？试试。如果你不确定会发生什么，记住如果没有可用的通道<code>default</code>会立即被触发。</p>
<p>Also, <code>time.After</code> is a channel of type <code>chan time.Time</code>. In the above example, we simply discard the value that was sent to the channel. If you want though, you can receive it:</p>
<p>同时，<code>time.After</code>的通道类型是<code>chan time.Time</code>。上面的例子中，我们简单的丢弃了发送给通道的值。如果你相要，你可以这样接收它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> t := &lt;-time.After(time.Millisecond * <span class="number">100</span>):</span><br><span class="line">  fmt.Println(<span class="string">&quot;timed out at&quot;</span>, t)</span><br></pre></td></tr></table></figure>

<p>Pay close attention to our <code>select</code>. Notice that we’re sending to <code>c</code> but receiving from <code>time.After</code>. <code>select</code> works the same regardless of whether we’re receiving from, sending to, or any combination of channels:</p>
<p>更近一步的看我们的<code>select</code>。注意我们向<code>c</code>发送数据，但是从<code>time.After</code>接收数据。<code>select</code>对无论是接收数据，发送数据，还是其他通道的组合，都是一样对待的：</p>
<ul>
<li><p>The first available channel is chosen.</p>
</li>
<li><p>If multiple channels are available, one is randomly picked.</p>
</li>
<li><p>If no channel is available, the default case is executed.</p>
</li>
<li><p>If there’s no default, select blocks.</p>
</li>
<li><p>第一个可用的通道被选择。</p>
</li>
<li><p>如果有多个通道可用，随机选择一个。</p>
</li>
<li><p>如果没有通道可用，默认条件被执行。</p>
</li>
<li><p>如果没有默认条件，选择阻塞。</p>
</li>
</ul>
<p>Finally, it’s common to see a <code>select</code> inside a <code>for</code>. Consider:</p>
<p>最后，<code>select</code>通常在<code>for</code>循环中使用。例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> data := &lt;-c:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;worker %d got %d\n&quot;</span>, w.id, data)</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(time.Millisecond * <span class="number">10</span>):</span><br><span class="line">    fmt.Println(<span class="string">&quot;Break time&quot;</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继续之前-Before-You-Continue"><a href="#继续之前-Before-You-Continue" class="headerlink" title="继续之前(Before You Continue)"></a>继续之前(Before You Continue)</h2><p>If you’re new to the world of concurrent programming, it might all seem rather overwhelming. It categorically demands considerably more attention and care. Go aims to make it easier.</p>
<p>如果你是并发编程的新手，它可能显得相当庞大。它绝对是需要相当多的重视和关注。 Go的目标就是使其更容易。</p>
<p>Goroutines effectively abstract what’s needed to run concurrent code. Channels help eliminate some serious bugs that can happen when data is shared by eliminating the sharing of data. This doesn’t just eliminate bugs, but it changes how one approaches concurrent programming. You start to think about concurrency with respect to message passing, rather than dangerous areas of code.</p>
<p>Go协程有效的抽象了需要并发执行的代码。通道协助消除了可能在数据共享时的严重Bug。这不只是消除了Bug,更是改变了并发编程的开发方式。你开始使用消息传递的方式来考虑并发，而不是危险的共享代码。</p>
<p>Having said that, I still make extensive use of the various synchronization primitives found in the <code>sync</code> and <code>sync/atomic</code> packages. I think it’s important to be comfortable with both. I encourage you to first focus on channels, but when you see a simple example that needs a short-lived lock, consider using a mutex or read-write mutex.</p>
<p>虽然这么说，我仍然广泛使用的各种同步原语中发现的<code>sync</code>和<code>sync/atomic</code>包。我觉得这两种情况都要适应是很重要的。我鼓励你先聚焦在通道上，但是如果你碰到只是需要短暂的多锁，建议你使用互斥锁或者读写互斥锁。</p>
<h1 id="结论-Conclusion"><a href="#结论-Conclusion" class="headerlink" title="结论(Conclusion)"></a>结论(Conclusion)</h1><p>I recently heard Go described as a <em>boring</em> language. Boring because it’s easy to learn, easy to write and, most importantly, easy to read. Perhaps, I did this reality a disservice. We <em>did</em> spend three chapters talking about types and how to declare variables after all.</p>
<p>我最近听说Go被描述为一门<em>单调的</em>语言。单调是因为它很容易学习，很容易编写，最为重要的是，很容易读。也许，我这是在帮倒忙，我确实花了三个章节来介绍类型和如何申请变量。</p>
<p>If you have a background in a statically typed language, much of what we saw was probably, at best, a refresher. That Go makes pointers visible and that slices are thin wrappers around arrays probably isn’t overwhelming to seasoned Java or C# developers.</p>
<p>如果你在静态类型语言的背景，大多数我们看到的，充其量只是复习。同时Go的指针可见性和切片的轻量封装对经验丰富的Java的C＃开发人员来说不算什么。</p>
<p>If you’ve mostly been making use of dynamic languages, you might feel a little different. It <em>is</em> a fair bit to learn. Not least of which is the various syntax around declaration and initialization. Despite being a fan of Go, I find that for all the progress towards simplicity, there’s something less than simple about it. Still, it comes down to some basic rules (like you can only declare variable once and <code>:=</code> does declare the variable) and fundamental understanding (like <code>new(X)</code> or <code>&amp;X&#123;&#125;</code> only allocate memory, but slices, maps and channels require more initialization and thus, <code>make</code>).</p>
<p>如果你更多的是使用动态语言，你可能会觉得有点不同。这<em>是</em>一点公平的学习。不过其中最重要的是各种声明和初始化的语法。虽然是一个Go粉，我发现所有的努力都是为了简单，还有一些致简的东西。仍然，它也有一些基本的规则（比如变量申明一次和<code>:=</code>已经申明了变量）和基本的了解（比如<code>new(X)</code> 或 <code>&amp;X&#123;&#125;</code>只是分配了内存，但切片，字典和通道就需要使用<code>make</code>来分配内存和初始化）。</p>
<p>Beyond this, Go gives us a simple but effective way to organize our code. Interfaces, return-based error handling, <code>defer</code> for resource management and a simple way to achieve composition.</p>
<p>除此之外，Go提供了一个简洁但又高效的方式来组织我们的代码。接口，基于返回值的错误处理，用于资源管理的<code>defer</code>和简单的实现组合。</p>
<p>Last but not least is the built-in support for concurrency. There’s little to say about goroutines other than they’re effective and simple (simple to use anyway). It’s a good abstraction. Channels are more complicated. I always think it’s important to understand basics before using high-level wrappers. I <em>do</em> think learning about concurrent programming without channels is useful. Still, channels are implemented in a way that, to me, doesn’t feel quite like a simple abstraction. They are almost their own fundamental building block. I say this because they change how you write and think about concurrent programming. Given how hard concurrent programming can be, that is definitely a good thing.</p>
<p>最后但是最重要的是它内置了对并发的支持。还有一点关于Go协程的要说就是它们高效和简单（反正使用简单）。这是很好的抽象。通道会更复杂一点。我一直认为在学习高级封装之前要掌握好基础。我<em>确认</em>认为不使用通道来进行并发编程是有益的。但是，通道的实现方式，对我来说，不太像是一个简单的抽象。它们有自己的基础构建。我这么说是因为它们改变了你对并发编程的思考和书写方式。鉴于并发编程的难度，这绝对是一个好事。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/chapter-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/chapter-5/" class="post-title-link" itemprop="url">Go Little Book - 第五章 - 特点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:45:32" itemprop="dateCreated datePublished" datetime="2018-11-22T10:45:32+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 21:23:05" itemprop="dateModified" datetime="2022-10-30T21:23:05+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>7 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第五章-特点（珍品？）（Chapter-5-Tidbits）"><a href="#第五章-特点（珍品？）（Chapter-5-Tidbits）" class="headerlink" title="第五章 - 特点（珍品？）（Chapter 5 - Tidbits）"></a>第五章 - 特点（珍品？）（Chapter 5 - Tidbits）</h1><p>In this chapter, we’ll talk about a miscellany of Go’s feature which didn’t quite fit anywhere else.</p>
<p>在这一章是，我们会来介绍一些Go的特性的杂烩，这些内容不太适合放在其他章节中。</p>
<h2 id="错误处理-Error-Handling"><a href="#错误处理-Error-Handling" class="headerlink" title="错误处理(Error Handling)"></a>错误处理(Error Handling)</h2><p>Go’s preferred way to deal with errors is through return values, not exceptions. Consider the <code>strconv.Atoi</code> function which takes a string and tries to convert it to an integer:</p>
<p>Go更喜欢用返回值而不是异常的方式来处理错误。例如<code>strconv.Atoi</code>函数将一个字符串转换成一个整数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">  <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(os.Args) != <span class="number">2</span> &#123;</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  n, err := strconv.Atoi(os.Args[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;not a valid number&quot;</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can create your own error type; the only requirement is that it fulfills the contract of the built-in <code>error</code> interface, which is:</p>
<p>你可以创建你自己的错误类型；唯一的要求就是需要实现内置接口<code>error</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">  Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>More commonly, we can create our own errors by importing the <code>errors</code> package and using it in the <code>New</code> function:</p>
<p>更为常见的是，我们可以通过导入<code>errors</code>包，并通过它的<code>New</code>函数来创建自己的错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(count <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> count &lt; <span class="number">1</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;Invalid count&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>There’s a common pattern in Go’s standard library of using error variables. For example, the <code>io</code> package has an <code>EOF</code> variable which is defined as:</p>
<p>在GO的标准库中，使用错误变量是一个常用的模式。例如， 在<code>io</code>包中有一个<code>EOF</code>变量是这样定义的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">&quot;EOF&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>This is a package variable (it’s defined outside of a function) which is publicly accessible (upper-case first letter). Various functions can return this error, say when we’re reading from a file or STDIN. If it makes contextual sense, you should use this error, too. As consumers, we can use this singleton:</p>
<p>这是一个公共（大写字母开关）的包变量（它定义有函数之外）。如果我们从文件或者标准输入时失败时，我们可以返回这个错误。为了更容易理解，你也应该用这个错误。作为使用者，我们可以用这个单件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;io&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> input <span class="keyword">int</span></span><br><span class="line">  _, err := fmt.Scan(&amp;input)</span><br><span class="line">  <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;no more input!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>As a final note, Go does have <code>panic</code> and <code>recover</code> functions. <code>panic</code> is like throwing an exception while <code>recover</code> is like <code>catch</code>; they are rarely used.</p>
<p>最后要注意的是，Go有<code>panic</code>和<code>recover</code>函数。<code>panic</code>像是抛出异常，而<code>recover</code>是捕获异常；它们不常使用。</p>
<h2 id="Defer-Defer"><a href="#Defer-Defer" class="headerlink" title="Defer(Defer)"></a>Defer(Defer)</h2><p>Even though Go has a garbage collector, some resources require that we explicitly release them. For example, we need to <code>Close()</code> files after we’re done with them. This sort of code is always dangerous. For one thing, as we’re writing a function, it’s easy to forget to <code>Close</code> something that we declared 10 lines up. For another, a function might have multiple return points. Go’s solution is the <code>defer</code> keyword:</p>
<p>虽然Go有垃圾回收机制，但是有些资源需要显示的释放它们。比如，当我们使用文件完了之后，需要调用<code>Close()</code>来关闭它们。这类代码总是很危险。其一，我们写一下函数的时候，如果申请一个资源超过10行，就很容易忘记<code>Close</code>。其二，一个函数可能会有多个返回点。Go的解决方案是使用<code>defer</code>关键字：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  file, err := os.Open(<span class="string">&quot;a_file_to_read&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line">  <span class="comment">// read the file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you try to run the above code, you’ll probably get an error (the file doesn’t exist). The point is to show how <code>defer</code> works. Whatever you <code>defer</code> will be executed after the method returns, even if it does so violently. This lets you release resources near where it’s initialized and takes care of multiple return points.</p>
<p>如果你尝试运行上面的代码，你可能收到一个错误（文件不存在）。这里展示的是<code>defer</code>是如何工作的。无论如何在函数返回时<code>defer</code>都会被执行，虽然这样有点极端。但这可以让你在初始化附近释放资源和不要操心多个返回点的问题。</p>
<h2 id="go-fmt-go-fmt"><a href="#go-fmt-go-fmt" class="headerlink" title="go fmt(go fmt)"></a>go fmt(go fmt)</h2><p>Most programs written in Go follow the same formatting rules, namely, a tab is used to indent and braces go on the same line as their statement.</p>
<p>绝大多数Go写的代码遵守有一个相同的格式化规则，也就是说，使用Tab来缩进和花括号与语句同一行。</p>
<p>I know, you have your own style and you want to stick to it. That’s what I did for a long time, but I’m glad I eventually gave in. A big reason for this is the <code>go fmt</code> command. It’s easy to use and authoritative (so no one argues over meaningless preferences).</p>
<p>我知道你有自己的代码风格并且严格遵守它。我一直以来也是这么做的，但是我最终还是放弃了。一个最在的原因就是<code>go fmt</code>命令。它很容用且权威（所以没有人会为了毫无意义的偏好而争论） </p>
<p>When you’re inside a project, you can apply the formatting rule to it and all sub-projects via:</p>
<p>当你在一个工程目录下，你可以通过下面的命令将工程下所有文件使用相同的格式化规则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go fmt ./...</span><br></pre></td></tr></table></figure>

<p>Give it a try. It does more than indent your code; it also aligns field declarations and alphabetically orders imports.</p>
<p>尝试一下吧。除了缩进代码，它还会自动对齐你的声明语句并将包导入按字母顺序排序。</p>
<h2 id="If初始化-Initialized-If"><a href="#If初始化-Initialized-If" class="headerlink" title="If初始化(Initialized If)"></a>If初始化(Initialized If)</h2><p>Go supports a slightly modified if-statement, one where a value can be initiated prior to the condition being evaluated:<br>Go提供了一种稍有不同的if声明，一个可以在条件执行之前声明和初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x := <span class="number">10</span>; count &gt; x &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>That’s a pretty silly example. More realistically, you might do something like:</p>
<p>这是一个非常简单的例子。更实际的例子是，你可能是这样做的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := process(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Interestingly, while the values aren’t available outside the if-statement, they are available inside any <code>else if</code> or <code>else</code>.</p>
<p>有趣的是，<code>if</code>语句中定义并初始化的值在<code>if</code>语句之外是不可用的，仅可以在<code>else if</code>和<code>else</code>语句中使用。</p>
<h2 id="空接口和转换-Empty-Interface-and-Conversions"><a href="#空接口和转换-Empty-Interface-and-Conversions" class="headerlink" title="空接口和转换(Empty Interface and Conversions)"></a>空接口和转换(Empty Interface and Conversions)</h2><p>In most object-oriented languages, a built-in base class, often named <code>object</code>, is the superclass for all other classes. Go, having no inheritance, doesn’t have such a superclass. What it does have is an empty interface with no methods: <code>interface&#123;&#125;</code>. Since every type implements all 0 of the empty interface’s methods, and since interfaces are implicitly implemented, every type fulfills the contract of the empty interface.</p>
<p>在大多数面向对象语言中，都有一种内置的基类，叫<code>object</code>，它是所有其他类的超类。但是go语言不支持继承，所以没有类似的超类。Go确实有一个没有任何方法的空接口：<code>interface&#123;&#125;</code>。因为接口都是隐式实现，每种类型都实现了空接口的0个方法，所以每种类型都实现了空接口的协议。</p>
<p> If we wanted to, we could write an <code>add</code> function with the following signature:</p>
<p>如果我们愿意，我们可以通过下面声明方式写一个<code>add</code>函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;, b <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To convert an interface variable to an explicit type, you use <code>.(TYPE)</code>:</p>
<p>将一个空接口变量转换成一个指定的类型，你可以使用<code>.(TYPE)</code>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a.(<span class="keyword">int</span>) + b.(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>Note that if the underlying type is not <code>int</code>, the above will result in an error.</p>
<p>需要注意如果底层类型示是一个<code>int</code>，上面的代码会导致一个错误。</p>
<p>You also have access to a powerful type switch:</p>
<p>你也可以通过switch使用强大的类型转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> a.(<span class="keyword">type</span>) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;a is now an int and equals %d\n&quot;</span>, a)</span><br><span class="line">  <span class="keyword">case</span> <span class="keyword">bool</span>, <span class="keyword">string</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You’ll see and probably use the empty interface more than you might first expect. Admittedly, it won’t result in clean code. Converting values back and forth is ugly and dangerous but sometimes, in a static language, it’s the only choice.</p>
<p>你会发现，空接口的使用会超出你的预期。诚然，这不会让代码变得简洁。来回转换值是丑陋和危险的，但有时候在静态类型语言中，这是唯一的选择。</p>
<h2 id="字符串和字节数组-Strings-and-Byte-Arrays"><a href="#字符串和字节数组-Strings-and-Byte-Arrays" class="headerlink" title="字符串和字节数组(Strings and Byte Arrays)"></a>字符串和字节数组(Strings and Byte Arrays)</h2><p>Strings and byte arrays are closely related. We can easily convert one to the other:</p>
<p>字符串和字节数组有密切关系，我们可以轻易的将它们转换成对方：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stra := <span class="string">&quot;the spice must flow&quot;</span></span><br><span class="line">byts := []<span class="keyword">byte</span>(stra)</span><br><span class="line">strb := <span class="keyword">string</span>(byts)</span><br></pre></td></tr></table></figure>

<p>In fact, this way of converting is common across various types as well. Some functions explicitly expect an <code>int32</code> or an <code>int64</code> or their unsigned counterparts. You might find yourself having to do things like:</p>
<p>事实上，这也是大多数类型的转换方式。一些函数明确指定一个<code>int32</code>或者<code>int64</code>或者相应的无符号类型。你可能会发现你自己不得不像下面这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64</span>(count)</span><br></pre></td></tr></table></figure>

<p>Still, when it comes to bytes and strings, it’s probably something you’ll end up doing often. Do note that when you use <code>[]byte(X)</code> or <code>string(X)</code>, you’re creating a copy of the data. This is necessary because strings are immutable.</p>
<p>然而，当涉及到字节和字符串时，这可能是你会经常做的事。当你使用<code>[]byte(X)</code>或者<code>string(X)</code>时务必注意，你创建了数据的拷贝。这是因为字符串的不可变性。</p>
<p>Strings are made of <code>runes</code> which are unicode code points. If you take the length of a string, you might not get what you expect. The following prints 3:</p>
<p>当字符串有由<code>unicode</code>字符码<code>runes</code>组成时。如果你计算字符串的长度时，可能得到的结果和你期待的不同。下面结果是输出3：</p>
<pre><code>fmt.Println(len(&quot;椒&quot;))
</code></pre>
<p>If you iterate over a string using <code>range</code>, you’ll get runes, not bytes. Of course, when you turn a string into a <code>[]byte</code> you’ll get the correct data.</p>
<p>如果你使用<code>range</code>迭代一个字符串，你得到的是<code>runes</code>,而不是<code>bytes</code>。当然，你将一个字符串转换为<code>[]byte</code>时，你得到的数据还是正确的。</p>
<h2 id="函数类型-Function-Type"><a href="#函数类型-Function-Type" class="headerlink" title="函数类型(Function Type)"></a>函数类型(Function Type)</h2><p>Functions are first-class types:<br>函数是第一类类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Add <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure>

<p>which can then be used anywhere – as a field type, as a parameter, as a return value.</p>
<p>可以在任何地方使用————可以做为一个字段，参数，返回值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Add <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(process(<span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(adder Add)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> adder(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using functions like this can help decouple code from specific implementations much like we achieve with interfaces.</p>
<p>像这样使用函数可以使你在一些特定实现时减少代码的耦合性，就像使用接口实现那样。</p>
<h2 id="继续之前-Before-You-Continue"><a href="#继续之前-Before-You-Continue" class="headerlink" title="继续之前(Before You Continue)"></a>继续之前(Before You Continue)</h2><p>We looked at various aspects of programming with Go. Most notably, we saw how error handling behaves and how to release resources such as connections and open files. Many people dislike Go’s approach to error handling. It can feel like a step backwards. Sometimes, I agree. Yet, I also find that it results in code that’s easier to follow. <code>defer</code> is an unusual but practical approach to resource management. In fact, it isn’t tied to resource management only. You can use <code>defer</code> for any purpose, such as logging when a function exits.</p>
<p>我们已经学习了Go编程的很多内容。显而易见，我们看见了错误处理的行为和资源释放如连接或者打开文件。很多人不喜欢Go的错误处理方式。它让人觉得这是一种退步。有些时候，我同意这种说法。然而，我也发现这会导致代码更易读。<code>defer</code>是一种不常见但很实用的资源管理手段。事实上，它不仅仅可以进行资源管理。你可以使用<code>defer</code>完成任何目的，例如当一个函数退出时打印日志记录。</p>
<p>Certainly, we haven’t looked at all of the tidbits Go has to offer. But you should be feeling comfortable enough to tackle whatever you come across.</p>
<p>当然，我们还没有学习Go提供的所有花絮。但是无论你遇到什么你应该可以轻松应对。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://l4qiang.me/2018/11/22/go/go-little-book/chapter-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="L4qiang">
      <meta itemprop="description" content="记录点滴，注重积累。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="CrazyAirhead">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2018/11/22/go/go-little-book/chapter-4/" class="post-title-link" itemprop="url">Go Little Book - 第四章 - 代码组织和接口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-11-22 10:45:23" itemprop="dateCreated datePublished" datetime="2018-11-22T10:45:23+08:00">2018-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 21:23:05" itemprop="dateModified" datetime="2022-10-30T21:23:05+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/go-little-book/" itemprop="url" rel="index"><span itemprop="name">go little book</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第四章-代码组织和接口（Chapter-4-Code-Organization-and-Interfaces）"><a href="#第四章-代码组织和接口（Chapter-4-Code-Organization-and-Interfaces）" class="headerlink" title="第四章 - 代码组织和接口（Chapter 4 - Code Organization and Interfaces）"></a>第四章 - 代码组织和接口（Chapter 4 - Code Organization and Interfaces）</h1><p>It’s now time to look at how to organize our code.</p>
<p>现在是时候来看看我们是怎么组织代码了。</p>
<h2 id="包（Packages）"><a href="#包（Packages）" class="headerlink" title="包（Packages）"></a>包（Packages）</h2><p>To keep more complicated libraries and systems organized, we need to learn about packages. In Go, package names follow the directory structure of your Go workspace. If we were building a shopping system, we’d probably start with a package name “shopping” and put our source files in <code>$GOPATH/src/shopping/</code>.</p>
<p>为了组织更复杂的类库和系统，我们需要了解包。在Go中，包名紧跟在工作目录结构之下。如果我们构建一个电商系统，我们可能以”shopping”命名包和把源文件存在<code>$GOPATH/src/shopping/</code>下。</p>
<p>We don’t want to put everything inside this folder though. For example, maybe we want to isolate some database logic inside its own folder. To achieve this, we create a subfolder at <code>$GOPATH/src/shopping/db</code>. The package name of the files within this subfolder is simply <code>db</code>, but to access it from another package, including the <code>shopping</code> package, we need to import <code>shopping/db</code>.</p>
<p>显然我们不想反所有的东西都放在这个目录。例如，我们希望在数据库目录下关联一些数据库的逻辑。要达到这个目的，我们创建了一个子目录<code>$GOPATH/src/shopping/db</code>。这个目录下的包名可以是简单的<code>db</code>，但是其他包需要访问这个包时，就需要包含<code>shopping</code>，我们需要这样导入<code>shopping/db</code>。</p>
<p>In other words, when you name a package, via the <code>package</code> keyword, you provide a single value, not a complete hierarchy (e.g., “shopping” or “db”). When you import a package, you specify the complete path.</p>
<p>换名话来说，当你命名一个包时，可以通过<code>package</code>关键字，你提供一个单一的值，不是完整的层级（比如，”shopping”或者”db”）。当你导入包时，你需要指定完整的路径。</p>
<p>Let’s try it. Inside your Go workspace’s <code>src</code> folder (which we set up in Getting Started of the Introduction), create a new folder called <code>shopping</code> and a subfolder within it called <code>db</code>.</p>
<p>让我们来试一试，在我们的Go的工作目录下的<code>src</code>文件夹中（我们在入门介绍中设置的），创建一个<code>shopping</code>的文件夹并创建一个<code>db</code>的子文件夹。</p>
<p>Inside of <code>shopping/db</code>, create a file called <code>db.go</code> and add the following code:</p>
<p>在<code>shopping/db</code>目录下，创建一个名为<code>db.go</code>的文件并添加如下代码： </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">  Price <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadItem</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">Item</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Item&#123;</span><br><span class="line">    Price: <span class="number">9.001</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice that the name of the package is the same as the name of the folder. Also, obviously, we aren’t actually accessing the database. We’re just using this as an example to show how to organize code.</p>
<p>注意下包名和文件夹的名字是一样的。显然，我们也没有真下的访问数据库。我们只是用这个例子来演示如何组织代码。</p>
<p>Now, create a file called <code>pricecheck.go</code> inside of the main <code>shopping</code> folder. Its content is:</p>
<p>现在，在主目录<code>shopping</code>下创建一个名为<code>pricecheck.go</code>的文件。它的代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shopping</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;shopping/db&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PriceCheck</span><span class="params">(itemId <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  item := db.LoadItem(itemId)</span><br><span class="line">  <span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> item.Price, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It’s tempting to think that importing <code>shopping/db</code> is somehow special because we’re inside the <code>shopping</code> package/folder already. In reality, you’re importing <code>$GOPATH/src/shopping/db</code>, which means you could just as easily import <code>test/db</code> so long as you had a package named <code>db</code> inside of your workspace’s <code>src/test</code> folder.</p>
<p>这很容易理解，导入<code>shopping/ db</code>有些特殊，因为我们是<code>shopping</code>包/文件夹中了。实际上，要导入<code>$ GOPATH/src/shopping/db</code>，这意味着你可以很容易地导入<code>test/db</code>，只要工作空间下的<code>src/test/db</code>的文件夹有一个<code>db</code>的包。</p>
<p>If you’re building a package, you don’t need anything more than what we’ve seen. To build an executable, you still need a <code>main</code>. The way I prefer to do this is to create a subfolder called <code>main</code> inside of <code>shopping</code> with a file called <code>main.go</code> and the following content:</p>
<p>如果你想建一个包，只需要我们看到的这些内容就可以了。要创建一个可执行程序，我们还需要一个<code>main</code>函数。我喜欢在<code>shopping</code>文件夹下建一个<code>main</code>文件夹并新增一个<code>main.go</code>的文件。它的内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;shopping&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(shopping.PriceCheck(<span class="number">4343</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You can now run your code by going into your <code>shopping</code> project and typing:</p>
<p>进入<code>shopping</code>目录输入如下内容可以运行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main/main.go</span><br></pre></td></tr></table></figure>

<h3 id="循环导入（Cyclical-Imports）"><a href="#循环导入（Cyclical-Imports）" class="headerlink" title="循环导入（Cyclical Imports）"></a>循环导入（Cyclical Imports）</h3><p>As you start writing more complex systems, you’re bound to run into cyclical imports. This happens when package A imports package B but package B imports package A (either directly or indirectly through another package). This is something the compiler won’t allow.</p>
<p>当你开始写一些更复杂的系统时，你不免会碰到循环导入的问题。当包A的导入了包B但是包B又导入了包A（无论是直接还是间接通过其他包导入）循环导入就发生了。这是编译器不允许的。</p>
<p>Let’s change our shopping structure to cause the error.</p>
<p>让我们来修改一下<code>shopping</code>的结构来引发这个错误。</p>
<p>Move the <code>Item</code> definition from <code>shopping/db/db.go</code> into <code>shopping/pricecheck.go</code>. Your <code>pricecheck.go</code> file should now look like:</p>
<p>把<code>Item</code>的定义从<code>shopping/db/db.go</code>移到<code>shopping/pricecheck.go</code>中。你的<code>pricecheck.go</code>应该看起来像这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shopping</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;shopping/db&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Item <span class="keyword">struct</span> &#123;</span><br><span class="line">  Price <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PriceCheck</span><span class="params">(itemId <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">  item := db.LoadItem(itemId)</span><br><span class="line">  <span class="keyword">if</span> item == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> item.Price, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>If you try to run the code, you’ll get a couple of errors from <code>db/db.go</code> about <code>Item</code> being undefined. This makes sense. <code>Item</code> no longer exists in the <code>db</code> package; it’s been moved to the shopping package. We need to change <code>shopping/db/db.go</code> to:</p>
<p>如果你尝试运行代码，你会从<code>db/db.go</code>中收到一些错误信息说<code>Item</code>未定义。这好理解。<code>Item</code>已经不在<code>db</code>包下了；这被移到了<code>shopping</code>包。我们需要修改<code>shopping/db/db.go</code>的代码为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;shopping&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadItem</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">shopping</span>.<span class="title">Item</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;shopping.Item&#123;</span><br><span class="line">    Price: <span class="number">9.001</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Now when you try to run the code, you’ll get a dreaded <em>import cycle not allowed</em> error. We solve this by introducing another package which contains shared structures. Your directory structure should look like:</p>
<p>现在当你尝试运行代码时，你会收到一个令人害怕的错误<em>import cycle not allowed</em>。我们通过引入一个包含共享结构的另一个包来解决这个问题。你的目录结构看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$GOPATH/src</span><br><span class="line">  - shopping</span><br><span class="line">    pricecheck.go</span><br><span class="line">    - db</span><br><span class="line">      db.go</span><br><span class="line">    - models</span><br><span class="line">      item.go</span><br><span class="line">    - main</span><br><span class="line">      main.go</span><br></pre></td></tr></table></figure>

<p><code>pricecheck.go</code> will still import <code>shopping/db</code>, but <code>db.go</code> will now import <code>shopping/models</code> instead of <code>shopping</code>, thus breaking the cycle. Since we moved the shared <code>Item</code> structure to <code>shopping/models/item.go</code>, we need to change <code>shopping/db/db.go</code> to reference the <code>Item</code> structure from <code>models</code> package:</p>
<p><code>pricecheck.go</code>一样是导入<code>shopping/db</code>，但是<code>db.go</code>现在要导入<code>shopping/models</code>来替换<code>shopping</code>，这样打破了循环。因为将共享结构体<code>Item</code>移到了<code>shopping/models/item.go</code>，我们需要修改<code>shopping/db/db.go</code>从<code>model</code>包中引用结构体<code>Item</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> db</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;shopping/models&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadItem</span><span class="params">(id <span class="keyword">int</span>)</span> *<span class="title">models</span>.<span class="title">Item</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;models.Item&#123;</span><br><span class="line">    Price: <span class="number">9.001</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You’ll often need to share more than just <code>models</code>, so you might have other similar folder named <code>utilities</code> and such. The important rule about these shared packages is that they shouldn’t import anything from the <code>shopping</code> package or any sub-packages. In a few sections, we’ll look at interfaces which can help us untangle these types of dependencies.</p>
<p>你常常需要的共享结构不仅仅是<code>models</code>，所以你可能还有一些类似<code>utilities</code>这样的文件夹。最重要的原则是这些共享对象，不能导入<code>shopping</code>包或者它的子包。要不了几个章节，我们会看到接口是如何解开这些依赖的。</p>
<h3 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h3><p>Go uses a simple rule to define what types and functions are visible outside of a package. If the name of the type or function starts with an uppercase letter, it’s visible. If it starts with a lowercase letter, it isn’t.</p>
<p>Go用一个非常简单的原则来决定一个包的类型和函数是否在包外可见。如果类型或者函数是以大写字母开头，就是可见的，如果是小写字母开头，就是不可见的。</p>
<p>This also applies to structure fields. If a structure field name starts with a lowercase letter, only code within the same package will be able to access them.</p>
<p>这对结构体的字段也是一样适用的。如果一个结构体的字段名是以小写字母开头，只有在同一个包里的代码可以访问它们。</p>
<p>For example, if our <code>items.go</code> file had a function that looked like:</p>
<p>例如：在我们的<code>items.go</code>文件中有这样的一个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewItem</span><span class="params">()</span> *<span class="title">Item</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>it could be called via <code>models.NewItem()</code>. But if the function was named <code>newItem</code>, we wouldn’t be able to access it from a different package.</p>
<p>可以通过<code>models.NewItem()</code>来调用。但是如果这个函数被命名为<code>newItem</code>，我们就不能在其他包里面来调用它了。</p>
<p>Go ahead and change the name of the various functions, types and fields from the <code>shopping</code> code. For example, if you rename the <code>Item&#39;s</code> <code>Price</code> field to <code>price</code>, you should get an error.</p>
<p>继续修改在<code>shopping</code>中修改函数，类型和字段的名字。例如，如果你修改<code>Item</code>的<code>Price</code>为<code>price</code>,你会收到一个编译错误。</p>
<h3 id="包管理（Package-Management）"><a href="#包管理（Package-Management）" class="headerlink" title="包管理（Package Management）"></a>包管理（Package Management）</h3><p>The <code>go</code> command we’ve been using to <code>run</code> and <code>build</code> has a <code>get</code> subcommand which is used to fetch third-party libraries. <code>go get</code> supports various protocols but for this example, we’ll be getting a library from Github, meaning, you’ll need <code>git</code> installed on your computer.</p>
<p>我们用来<code>run</code>和<code>build</code>的<code>go</code>命令，它还一个<code>get</code>的子命令用来获取第三方的类库。<code>go get</code>支持多种协议，但是这里，我们将从Github上获取一个类库。这是说，你要在你的电脑上安装好<code>git</code>。</p>
<p>Assuming you already have git installed, from a shell/command prompt, enter:</p>
<p>假设你已经安装好了git，打开一个shell/命令提示符，输入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/mattn/go-sqlite3</span><br></pre></td></tr></table></figure>

<p><code>go get</code> fetches the remote files and stores them in your workspace. Go ahead and check your <code>$GOPATH/src</code>. In addition to the <code>shopping</code> project that we created, you’ll now see a <code>github.com</code> folder. Within, you’ll see a <code>mattn</code> folder which contains a <code>go-sqlite3</code> folder.</p>
<p><code>go get</code>获取远程文件并把它们存在你的工作目录中。到<code>$GOPATH/src</code>目录中检查一下。除了我们自己创建的<code>shopping</code>项目外，还会看到一个<code>github.com</code>文件夹。里面你会看到一个包含<code>go-sqlite3</code>文件夹的<code>mattn</code>文件夹。</p>
<p>We just talked about how to import packages that live in our workspace. To use our newly gotten <code>go-sqlite3</code> package, we’d import it like so:</p>
<p>我们刚介绍了在工作区中如何导入包。要用我们刚刚获取到的<code>go-sqlite3</code>包，我们需要像这样来导入它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;github.com/mattn/go-sqlite3&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>I know this looks like a URL but in reality, it’ll simply import the <code>go-sqlite3</code> package which it expects to find in <code>$GOPATH/src/github.com/mattn/go-sqlite3</code>.</p>
<p>我知道这看起来像是一个URL，但实际上，如果知道是在<code>$GOPATH/src/github.com/mattn/go-sqlite3</code>目录，导入<code>go-sqlite3</code>包是很简单的。</p>
<h3 id="依赖管理（Dependency-Management）"><a href="#依赖管理（Dependency-Management）" class="headerlink" title="依赖管理（Dependency Management）"></a>依赖管理（Dependency Management）</h3><p><code>go get</code> has a couple of other tricks up its sleeve. If we <code>go get</code> within a project, it’ll scan all the files, looking for <code>imports</code> to third-party libraries and will download them. In a way, our own source code becomes a <code>Gemfile</code> or <code>package.json</code>.</p>
<p><code>go get</code>有一些其他的戏法。如果我们在一个项目中执行<code>go get</code>，它会扫描所有文件并查找所有导入的第三方库，然后下载这些第三方库。某种程度上说，我们自己的源代码变成一个<code>Gemfile</code>或者<code>package.json</code>。</p>
<p>If you call <code>go get -u</code> it’ll update the packages (or you can update a specific package via <code>go get -u FULL_PACKAGE_NAME</code>).</p>
<p>执行<code>go get -u</code>将更新你的包（或者你可以通过<code>go get -u FULL_PACKAGE_NAME</code>更新指定的包）</p>
<p>Eventually, you might find <code>go get</code> inadequate. For one thing, there’s no way to specify a revision, it always points to the master/head/trunk/default. This is an even larger problem if you have two projects needing different versions of the same library.</p>
<p>最后，你可能发现了<code>go get</code>的一些不足。首先，它不能指定一个修订，它会一直指向<code>master/head/trunk/default</code>。这是一个严重的问题，尤其当你有2个项目需要同一个库的不同版本时。</p>
<p>To solve this, you can use a third-party dependency management tool. They are still young, but two promising ones are <a target="_blank" rel="noopener" href="https://github.com/nitrous-io/goop">goop</a> and <a target="_blank" rel="noopener" href="https://github.com/tools/godep">godep</a>. A more complete list is available at the <a target="_blank" rel="noopener" href="https://code.google.com/p/go-wiki/wiki/PackageManagementTools">go-wiki</a>.</p>
<p>为了解决这个问题，你可以使用一个第三方的依赖管理工具。虽然还不太成熟，但是有2个依赖管理工具比较有前景，即<a target="_blank" rel="noopener" href="https://github.com/nitrous-io/goop">goop</a>和<a target="_blank" rel="noopener" href="https://github.com/tools/godep">godep</a>。更完整的列表可以参考<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/PackageManagementTools">go-wiki</a>。</p>
<h2 id="接口（Interfaces）"><a href="#接口（Interfaces）" class="headerlink" title="接口（Interfaces）"></a>接口（Interfaces）</h2><p>Interfaces are types that define a contract but not an implementation. Here’s an example:</p>
<p>接中是一种定义了协议但没有实现的类型。这是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">interface</span> &#123;</span><br><span class="line">  Log(message <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>You might be wondering what purpose this could possibly serve. Interfaces help decouple your code from specific implementations. For example, we might have various types of loggers:</p>
<p>你可能会想知道这么做有什么目的。接口可以帮的的代码从特定的实现中解藕出来。例如,我们可能有多种类型的日志：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SqlLogger <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">type</span> ConsoleLogger <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"><span class="keyword">type</span> FileLogger <span class="keyword">struct</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>Yet by programming against the interface, rather than these concrete implementations, we can easily change (and test) which we use without any impact to our code.</p>
<p>是的，能过接口而不是这些具体的实现来编程，我们可以很容易的在不影响我们的代码的基础上修改（和测试）。</p>
<p>How would you use one? Just like any other type, it could be a structure’s field:</p>
<p>你要如何来使用？就像其他类型一样，它可以是一个结构体的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">  logger Logger</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>or a function parameter (or return value):</p>
<p>或者是一个函数的参数（或者访回值）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">process</span><span class="params">(logger Logger)</span></span> &#123;</span><br><span class="line">  logger.Log(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In a language like C# or Java, we have to be explicit when a class implements an interface:</p>
<p>在像C#或者Java的语言中，我们必须显示的申请明一个类实现了一个接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class ConsoleLogger : Logger &#123;</span><br><span class="line">  public void Logger(message <span class="keyword">string</span>) &#123;</span><br><span class="line">    Console.WriteLine(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>In Go, this happens implicitly. If your structure has a function name <code>Log</code> with a <code>string</code> parameter and no return value, then it can be used as a <code>Logger</code>. This cuts down on the verboseness of using interfaces:</p>
<p>在Go中，这是隐式的。如果的结构体有一个名为<code>Log</code>的函数，有一个<code>string</code>的参数和没有返回值，那么它就可以当作<code>Logger</code>来使用。这减少了使用接口时的繁索：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ConsoleLogger <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l ConsoleLogger)</span> <span class="title">Log</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  fmt.Println(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>It also tends to promote small and focused interfaces. The standard library is full of interfaces. The <code>io</code> package has a handful of popular ones such as <code>io.Reader</code>, <code>io.Writer</code>, and <code>io.Closer</code>. If you write a function that expects a parameter that you’ll only be calling <code>Close()</code> on, you absolutely should accept an <code>io.Closer</code> rather than whatever concrete type you’re using.</p>
<p>这也会倾向于促进接口的小巧和单一。标准库中到处都是接口。在<code>io</code>包中有一些流行的接口，如<code>io.Reader</code>, <code>io.Writer</code>, 和<code>io.Closer</code>。如果你要写一个函数需要一个参数但只调用它的<code>Close()</code>方法，你绝对可以使用<code>io.Closer</code>接口需不是任何具体的类型。</p>
<p>Interfaces can also participate in composition. And, interfaces themselves can be composed of other interfaces. For example, <code>io.ReadCloser</code> is an interface composed of the <code>io.Reader</code> interface as well as the <code>io.Closer</code> interface.</p>
<p>接口也可以组合。也就是说接口可以有其他接口组成。例如，<code>io.ReadCloser</code>就是由接口<code>io.Reader</code>和<code>io.Closer</code>接口组成。</p>
<p>Finally, interfaces are commonly used to avoid cyclical imports. Since they don’t have implementations, they’ll have limited dependencies.</p>
<p>最后，接口常用于避免循环导入。由于接口没有实现，他们的依赖关系有限。</p>
<h2 id="继续之前（Before-You-Continue）"><a href="#继续之前（Before-You-Continue）" class="headerlink" title="继续之前（Before You Continue）"></a>继续之前（Before You Continue）</h2><p>Ultimately, how you structure your code around Go’s workspace is something that you’ll only feel comfortable with after you’ve written a couple of non-trivial projects. What’s most important for you to remember is the tight relationship between package names and your directory structure (not just within a project, but within the entire workspace).</p>
<p>最后，当你试着用go写一些简单的项目之后，你会习惯在go语言的工作区中组织代码的方式。最重要是的记住go语言中的包名和你的目录结构有密切关系（不仅仅在一个项目中，在整个工作空间都如此）。</p>
<p>The way Go handles visibility of types is straightforward and effective. It’s also consistent. There are a few things we haven’t looked at, such as constants and global variables but rest assured, their visibility is determined by the same naming rule.</p>
<p>go语言处理类型的可见性方法是简单有效的。也是一致的。还有一些内容我们没有介绍，例如常量和全局变量，但是不用担心，它们的可见性也是遵循同样的规则。</p>
<p>Finally, if you’re new to interfaces, it might take some time before you get a feel for them. However, the first time you see a function that expects something like <code>io.Reader</code>, you’ll find yourself thanking the author for not demanding more than he or she needed.</p>
<p>最后，如果你不熟悉go语言中的接口，你可能需要花一些时间去感受它们。无论如何，当你首次看见一个函数需要例如<code>io.Reader</code>之类的参数时，你会发现你自己感激作者的要求不是太苛刻。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/22/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/24/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">L4qiang</p>
  <div class="site-description" itemprop="description">记录点滴，注重积累。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">259</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">112</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">111</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/crazy-airhead" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;crazy-airhead" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:L4qiang@gmail.com" title="E-Mail → mailto:L4qiang@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/enderjo" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;enderjo" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://ri.cms.firesbox.com/" title="https:&#x2F;&#x2F;ri.cms.firesbox.com" rel="noopener" target="_blank">践行群官方情报站</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">L4qiang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">557k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:27</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  















    <div id="pjax">
  

  


    </div>
</body>
</html>
